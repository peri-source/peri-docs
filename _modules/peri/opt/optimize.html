
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>peri.opt.optimize &#8212; PERI 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/mathconf.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">PERI 0.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for peri.opt.optimize</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">map</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">object</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">gc</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="k">import</span> <span class="n">randint</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="k">import</span> <span class="n">newton</span><span class="p">,</span> <span class="n">minimize_scalar</span>

<span class="kn">from</span> <span class="nn">peri.util</span> <span class="k">import</span> <span class="n">Tile</span><span class="p">,</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">peri</span> <span class="k">import</span> <span class="n">states</span>
<span class="kn">from</span> <span class="nn">peri</span> <span class="k">import</span> <span class="n">models</span> <span class="k">as</span> <span class="n">mdl</span>
<span class="kn">from</span> <span class="nn">peri.logger</span> <span class="k">import</span> <span class="n">log</span>
<span class="n">CLOG</span> <span class="o">=</span> <span class="n">log</span><span class="o">.</span><span class="n">getChild</span><span class="p">(</span><span class="s1">&#39;opt&#39;</span><span class="p">)</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">If the LMEngine gets &#39;stuck&#39; on the first loop attempt, since _last_vals ==</span>
<span class="sd">param_vals the LM will check completion and terminate. Leaving as is since I&#39;ve</span>
<span class="sd">only got this to happen when it&#39;s at the minimum...</span>
<span class="sd">TODO:</span>
<span class="sd">    1. burn -- 2 loops of globals is only good for the first few loops; after</span>
<span class="sd">            that it&#39;s overkill. Best to make a 3rd mode now, since the</span>
<span class="sd">            psf and zscale move around without a set of burns.</span>

<span class="sd">To add:</span>
<span class="sd">1. AugmentedState: ILM scale options? You&#39;d need a way to get an overall scale</span>
<span class="sd">    block, which would probably need to come from the ILM itself.</span>
<span class="sd">6. With opt using big regions for particles, globals, it makes sense to</span>
<span class="sd">    put stuff back on the card again....</span>

<span class="sd">To fix:</span>
<span class="sd">1.  AugmentedState relies on the particles having radii. Prob OK but make</span>
<span class="sd">    sure things play nice with objects w/o radii.</span>
<span class="sd">2.  Right now, when marquardt_damping=False (the default, which works nicely),</span>
<span class="sd">    the correct damping parameter scales with the image size. For each element</span>
<span class="sd">    of J is O(1), so JTJ[i,j]~1^2 * N ~ N where N is the number of residuals</span>
<span class="sd">    pixels. But the damping matrix only matters in its overall ratio to J.</span>
<span class="sd">    So, changing max_mem or changing the image size will affect what a</span>
<span class="sd">    reasonable damping is. One way to do this is to scale the damping by</span>
<span class="sd">    the size of the residuals..........................................</span>

<span class="sd">LM Algorithm is:</span>
<span class="sd">1. Evaluate J_ia = df(xi,mu)/dmu_a</span>
<span class="sd">2. Solve the for delta:</span>
<span class="sd">    (J^T*J + l*Diag(J^T*J))*delta = J^T(y-f(xi,mu))     (1)</span>
<span class="sd">3. Update mu -&gt; mu + delta</span>

<span class="sd">To solve eq. (1), we need to:</span>
<span class="sd">1. Construct the matrix JTJ = J^T*J</span>
<span class="sd">2. Construct the matrix A=JTJ + l*Diag(JTJ)</span>
<span class="sd">3. Construct err= y-f(x,beta)</span>
<span class="sd">4. np.linalg.leastsq(A,err, rcond=min_eigval) to avoid near-zero eigenvalues</span>

<span class="sd">My only change to this is, instead of calculating J_ia, we calculate</span>
<span class="sd">J_ia for a small subset (say 1%) of the pixels in the image randomly selected,</span>
<span class="sd">rather than for all the pixels (in addition to leastsq solution instead of</span>
<span class="sd">linalg.solve)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">get_rand_Japprox</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">num_inds</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">include_cost</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates a random approximation to J by returning J only at a</span>
<span class="sd">    set of random pixel/voxel locations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        s : :class:`peri.states.State`</span>
<span class="sd">            The state to calculate J for.</span>
<span class="sd">        params : List</span>
<span class="sd">            The list of parameter names to calculate the gradient of.</span>
<span class="sd">        num_inds : Int, optional.</span>
<span class="sd">            The number of pix/voxels at which to calculate the random</span>
<span class="sd">            approximation to J. Default is 1000.</span>
<span class="sd">        include_cost : Bool, optional</span>
<span class="sd">            Set to True to append a finite-difference measure of the full</span>
<span class="sd">            cost gradient onto the returned J.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        All kwargs parameters get passed to s.gradmodel only.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        J : numpy.ndarray</span>
<span class="sd">            [d, num_inds] array of J, at the given indices.</span>

<span class="sd">        return_inds : numpy.ndarray or slice</span>
<span class="sd">            [num_inds] element array or slice(0, None) of the model</span>
<span class="sd">            indices at which J was evaluated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">tot_pix</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">num_inds</span> <span class="o">&lt;</span> <span class="n">tot_pix</span><span class="p">:</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">tot_pix</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">num_inds</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">slicer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">return_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">return_inds</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">slicer</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_cost</span><span class="p">:</span>
        <span class="n">Jact</span><span class="p">,</span> <span class="n">ge</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">gradmodel_e</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">inds</span><span class="o">=</span><span class="n">inds</span><span class="p">,</span> <span class="n">slicer</span><span class="o">=</span><span class="n">slicer</span><span class="p">,</span><span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">Jact</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">J</span> <span class="o">=</span> <span class="p">[</span><span class="n">Jact</span><span class="p">,</span> <span class="n">ge</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">J</span> <span class="o">=</span> <span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">gradmodel</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">inds</span><span class="o">=</span><span class="n">inds</span><span class="p">,</span> <span class="n">slicer</span><span class="o">=</span><span class="n">slicer</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;J:</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">J</span><span class="p">,</span> <span class="n">return_inds</span>

<span class="k">def</span> <span class="nf">name_globals</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">remove_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of the global parameter names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        s : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to name the globals of.</span>
<span class="sd">        remove_params : Set or None</span>
<span class="sd">            A set of unique additional parameters to remove from the globals</span>
<span class="sd">            list.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        all_params : list</span>
<span class="sd">            The list of the global parameter names, with each of</span>
<span class="sd">            remove_params removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_params</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">params</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">param_particle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">obj_get_positions</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">all_params</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">remove_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">remove_params</span><span class="p">):</span>
            <span class="n">all_params</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">all_params</span>

<span class="k">def</span> <span class="nf">get_num_px_jtj</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">nparams</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">min_redundant</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the number of pixels to use for J at a given memory usage.</span>

<span class="sd">    Tries to pick a number of pixels as (size of image / `decimate`).</span>
<span class="sd">    However, clips this to a maximum size and minimum size to ensure that</span>
<span class="sd">    (1) too much memory isn&#39;t used and (2) J has enough elements so that</span>
<span class="sd">    the inverse of JTJ will be well-conditioned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        s : :class:`peri.states.State`</span>
<span class="sd">            The state on which to calculate J.</span>
<span class="sd">        nparams : Int</span>
<span class="sd">            The number of parameters that will be included in J.</span>
<span class="sd">        decimate : Int, optional</span>
<span class="sd">            The amount to decimate the number of pixels in the image by,</span>
<span class="sd">            i.e. tries to pick num_px = size of image / decimate.</span>
<span class="sd">            Default is 1</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum allowed memory, in bytes, for J to occupy at</span>
<span class="sd">            double-precision. Default is 1e9.</span>
<span class="sd">        min_redundant : Int, optional</span>
<span class="sd">            The number of pixels must be at least `min_redundant` *</span>
<span class="sd">            `nparams`. If not, an error is raised. Default is 20</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        num_px : Int</span>
<span class="sd">            The number of pixels at which to calcualte J.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#1. Max for a given max_mem:</span>
    <span class="n">px_mem</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_mem</span> <span class="o">//</span> <span class="mi">8</span> <span class="o">//</span> <span class="n">nparams</span><span class="p">)</span> <span class="c1">#1 float = 8 bytes</span>
    <span class="c1">#2. num_pix for a given redundancy</span>
    <span class="n">px_red</span> <span class="o">=</span> <span class="n">min_redundant</span><span class="o">*</span><span class="n">nparams</span>
    <span class="c1">#3. And # desired for decimation</span>
    <span class="n">px_dec</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">size</span><span class="o">//</span><span class="n">decimate</span>

    <span class="k">if</span> <span class="n">px_red</span> <span class="o">&gt;</span> <span class="n">px_mem</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Insufficient max_mem for desired redundancy.&#39;</span><span class="p">)</span>
    <span class="n">num_px</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">px_dec</span><span class="p">,</span> <span class="n">px_red</span><span class="p">,</span> <span class="n">px_mem</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">num_px</span>

<span class="k">def</span> <span class="nf">vectorize_damping</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">increase_list</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;psf-&#39;</span><span class="p">,</span> <span class="mf">1e4</span><span class="p">]]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a non-constant damping vector, allowing certain parameters to be</span>
<span class="sd">    more strongly damped than others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        params : List</span>
<span class="sd">            The list of parameter names, in order.</span>
<span class="sd">        damping : Float</span>
<span class="sd">            The default value of the damping.</span>
<span class="sd">        increase_list: List</span>
<span class="sd">            A nested 2-element list of the params to increase and their</span>
<span class="sd">            scale factors. All parameters containing the string</span>
<span class="sd">            increase_list[i][0] are increased by a factor increase_list[i][1].</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        damp_vec : np.ndarray</span>
<span class="sd">            The damping vector to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">damp_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">))</span> <span class="o">*</span> <span class="n">damping</span>
    <span class="k">for</span> <span class="n">nm</span><span class="p">,</span> <span class="n">fctr</span> <span class="ow">in</span> <span class="n">increase_list</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">damp_vec</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nm</span> <span class="ow">in</span> <span class="n">params</span><span class="p">[</span><span class="n">a</span><span class="p">]:</span>
                <span class="n">damp_vec</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*=</span> <span class="n">fctr</span>
    <span class="k">return</span> <span class="n">damp_vec</span>

<span class="k">def</span> <span class="nf">low_mem_sq</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">100000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;np.dot(m, m.T) with low mem usage, by doing it in small steps&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">c_contiguous</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;m must be C ordered for this to work with less mem.&#39;</span><span class="p">)</span>
    <span class="c1"># -- can make this even faster with pre-allocating arrays, but not worth it</span>
    <span class="c1"># right now</span>
    <span class="c1"># mmt = np.zeros([m.shape[0], m.shape[0]])  #6us</span>
    <span class="c1"># mt_tmp = np.zeros([step, m.shape[0]])</span>
    <span class="c1"># for a in range(0, m.shape[1], step):</span>
        <span class="c1"># mx = min(a+step, m.shape[1])</span>
        <span class="c1"># mt_tmp[:mx-a,:] = m.T[a:mx]</span>
        <span class="c1"># # np.dot(m_tmp, m.T, out=mmt[a:mx])</span>
        <span class="c1"># # np.dot(m, m[a:mx].T, out=mmt[:, a:mx])</span>
        <span class="c1"># np.dot(m[:,a:mx], mt_tmp[:mx], out=mmt)</span>
    <span class="c1"># return mmt</span>
    <span class="n">mmt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>  <span class="c1">#6us</span>
    <span class="c1"># m_tmp = np.zeros([step, m.shape[1]])</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">):</span>
        <span class="n">mx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">step</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># m_tmp[:] = m[a:mx]</span>
        <span class="c1"># np.dot(m_tmp, m.T, out=mmt[a:mx])</span>
        <span class="n">mmt</span><span class="p">[:,</span> <span class="n">a</span><span class="p">:</span><span class="n">mx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">mx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mmt</span>

<span class="c1">#=============================================================================#</span>
<span class="c1">#               ~~~~~  Particle Optimization stuff  ~~~~~</span>
<span class="c1">#=============================================================================#</span>
<span class="k">def</span> <span class="nf">find_particles_in_tile</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the particles in a tile, as numpy.ndarray of ints.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        state : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to locate particles in.</span>
<span class="sd">        tile : :class:`peri.util.Tile` instance</span>
<span class="sd">            Tile of the region inside which to check for particles.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        numpy.ndarray, int</span>
<span class="sd">            The indices of the particles in the tile.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bools</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">obj_get_positions</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bools</span><span class="o">.</span><span class="n">size</span><span class="p">)[</span><span class="n">bools</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">separate_particles_into_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">doshift</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Separates particles into convenient groups for optimization.</span>

<span class="sd">    Given a state, returns a list of groups of particles. Each group of</span>
<span class="sd">    particles are located near each other in the image. Every particle</span>
<span class="sd">    located in the desired region is contained in exactly 1 group.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s : :class:`peri.states.ImageState`</span>
<span class="sd">        The peri state to find particles in.</span>
<span class="sd">    region_size : Int or 3-element list-like of ints, optional</span>
<span class="sd">        The size of the box. Groups particles into boxes of shape</span>
<span class="sd">        (region_size[0], region_size[1], region_size[2]). If region_size</span>
<span class="sd">        is a scalar, the box is a cube of length region_size.</span>
<span class="sd">        Default is 40.</span>
<span class="sd">    bounds : 2-element list-like of 3-element lists, optional</span>
<span class="sd">        The sub-region of the image over which to look for particles.</span>
<span class="sd">            bounds[0]: The lower-left  corner of the image region.</span>
<span class="sd">            bounds[1]: The upper-right corner of the image region.</span>
<span class="sd">        Default (None -&gt; ([0,0,0], s.oshape.shape)) is a box of the entire</span>
<span class="sd">        image size, i.e. the default places every particle in the image</span>
<span class="sd">        somewhere in the groups.</span>
<span class="sd">    doshift : {True, False, `&#39;rand&#39;`}, optional</span>
<span class="sd">        Whether or not to shift the tile boxes by half a region size, to</span>
<span class="sd">        prevent the same particles to be chosen every time. If `&#39;rand&#39;`,</span>
<span class="sd">        randomly chooses either True or False. Default is False</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    particle_groups : List</span>
<span class="sd">        Each element of particle_groups is an int numpy.ndarray of the</span>
<span class="sd">        group of nearby particles. Only contains groups with a nonzero</span>
<span class="sd">        number of particles, so the elements don&#39;t necessarily correspond</span>
<span class="sd">        to a given image region.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bounding_tile</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">oshape</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">pad</span><span class="p">)</span> <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span>
            <span class="n">Tile</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">bounding_tile</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">region_size</span> <span class="k">if</span>
            <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">region_size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">region_size</span><span class="p">))</span>

    <span class="n">n_translate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bounding_tile</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">rs</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">particle_groups</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">tile</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">bounding_tile</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">bounding_tile</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="n">rs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">doshift</span> <span class="o">==</span> <span class="s1">&#39;rand&#39;</span><span class="p">:</span>
        <span class="n">doshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">doshift</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">rs</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">n_translate</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">n_translate</span><span class="p">])</span>

    <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">find_particles_in_tile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">*</span> <span class="n">rs</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)),</span> <span class="o">*</span><span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">deltas</span><span class="p">]))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">_check_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">groups</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">groups</span>

<span class="k">def</span> <span class="nf">_check_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">groups</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Ensures that all particles are included in exactly 1 group&quot;&quot;&quot;</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
        <span class="n">ans</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">ans</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">obj_get_radii</span><span class="p">()):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">obj_get_radii</span><span class="p">()</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ans</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">calc_particle_group_region_size</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the biggest region size for LM particle optimization with a</span>
<span class="sd">    given memory constraint.</span>

<span class="sd">    Input Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        s : :class:`peri.states.ImageState`</span>
<span class="sd">            The state with the particles</span>
<span class="sd">        region_size : Int or 3-element list-like of ints, optional.</span>
<span class="sd">            The initial guess for the region size. Default is 40</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum memory for the optimizer to take. Default is 1e9</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        bounds: 2-element list-like of 3-element lists.</span>
<span class="sd">            The sub-region of the image over which to look for particles.</span>
<span class="sd">                bounds[0]: The lower-left  corner of the image region.</span>
<span class="sd">                bounds[1]: The upper-right corner of the image region.</span>
<span class="sd">            Default (None -&gt; ([0,0,0], s.oshape.shape)) is a box of the entire</span>
<span class="sd">            image size, i.e. the default places every particle in the image</span>
<span class="sd">            somewhere in the groups.</span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        region_size : numpy.ndarray of ints of the region size.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">region_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">region_size</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calc_mem_usage</span><span class="p">(</span><span class="n">region_size</span><span class="p">):</span>
        <span class="n">rs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">region_size</span><span class="p">)</span>
        <span class="n">particle_groups</span> <span class="o">=</span> <span class="n">separate_particles_into_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span>
                <span class="n">rs</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># The actual mem usage is the max of the memory usage of all the</span>
        <span class="c1"># particle groups. However this is too slow. So instead we use the</span>
        <span class="c1"># max of the memory of the biggest 5 particle groups:</span>
        <span class="n">numpart</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">particle_groups</span><span class="p">]</span>
        <span class="n">biggroups</span> <span class="o">=</span> <span class="p">[</span><span class="n">particle_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">numpart</span><span class="p">)[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]]</span>
        <span class="k">def</span> <span class="nf">get_tile_jsize</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
            <span class="n">nms</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">param_particle</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get_update_io_tiles</span><span class="p">(</span><span class="n">nms</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">get_values</span><span class="p">(</span><span class="n">nms</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">tile</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">nms</span><span class="p">)</span>
        <span class="n">mems</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="o">*</span><span class="n">get_tile_jsize</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">biggroups</span><span class="p">]</span>  <span class="c1"># 8 for bytes/float64</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">mems</span><span class="p">)</span>

    <span class="n">im_shape</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">oshape</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">calc_mem_usage</span><span class="p">(</span><span class="n">region_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_mem</span><span class="p">:</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">calc_mem_usage</span><span class="p">(</span><span class="n">region_size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_mem</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">region_size</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)):</span>
            <span class="n">region_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">region_size</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">while</span> <span class="p">((</span><span class="n">calc_mem_usage</span><span class="p">(</span><span class="n">region_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_mem</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">region_size</span> <span class="o">&lt;</span> <span class="n">im_shape</span><span class="p">)):</span>
            <span class="n">region_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">region_size</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">im_shape</span><span class="p">)</span>
        <span class="n">region_size</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">#need to be &lt; memory, so we undo 1 iteration</span>

    <span class="k">return</span> <span class="n">region_size</span>

<span class="k">def</span> <span class="nf">get_residuals_update_tile</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">padded_tile</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translates a tile in the padded image to the unpadded image.</span>

<span class="sd">    Given a state and a tile that corresponds to the padded image, returns</span>
<span class="sd">    a tile that corresponds to the the corresponding pixels of the difference</span>
<span class="sd">    image</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        st : :class:`peri.states.State`</span>
<span class="sd">            The state</span>
<span class="sd">        padded_tile : :class:`peri.util.Tile`</span>
<span class="sd">            The tile in the padded image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        :class:`peri.util.Tile`</span>
<span class="sd">            The tile corresponding to padded_tile in the unpadded image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inner_tile</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">ishape</span><span class="o">.</span><span class="n">intersection</span><span class="p">([</span><span class="n">st</span><span class="o">.</span><span class="n">ishape</span><span class="p">,</span> <span class="n">padded_tile</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">inner_tile</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">st</span><span class="o">.</span><span class="n">pad</span><span class="p">)</span>

<span class="c1">#=============================================================================#</span>
<span class="c1">#         ~~~~~        Class/Engine LM minimization Stuff     ~~~~~</span>
<span class="c1">#=============================================================================#</span>

<span class="k">def</span> <span class="nf">find_best_step</span><span class="p">(</span><span class="n">err_vals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the index of the lowest of the passed values. Catches nans etc.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">err_vals</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All err_vals are nans!&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">err_vals</span><span class="p">)</span>

<div class="viewcode-block" id="LMEngine"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine">[docs]</a><span class="k">class</span> <span class="nc">LMEngine</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt engine with all the options from the M. Transtrum</span>
<span class="sd">    J. Sethna 2012 ArXiV paper [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        damping: Float, optional</span>
<span class="sd">            The initial damping factor for Levenberg-Marquardt. Adjusted</span>
<span class="sd">            internally. Default is 1.</span>
<span class="sd">        increase_damp_factor: Float, optional</span>
<span class="sd">            The amount to increase damping by when an attempted step</span>
<span class="sd">            has failed. Default is 3.</span>
<span class="sd">        decrease_damp_factor: Float, optional</span>
<span class="sd">            The amount to decrease damping by after a successful step.</span>
<span class="sd">            Default is 8. increase_damp_factor and decrease_damp_factor</span>
<span class="sd">            must not have all the same factors.</span>

<span class="sd">        min_eigval: Float scalar, optional, &lt;&lt;1.</span>
<span class="sd">            The minimum eigenvalue to use in inverting the JTJ matrix,</span>
<span class="sd">            to avoid degeneracies in the parameter space (i.e. &#39;rcond&#39;</span>
<span class="sd">            in np.linalg.lstsq). Default is 1e-12.</span>
<span class="sd">        marquardt_damping: Bool, optional</span>
<span class="sd">            Set to False to use Levenberg damping (damping matrix</span>
<span class="sd">            proportional to the identiy) instead of Marquardt damping</span>
<span class="sd">            (damping matrix proportional to the diagonal terms of JTJ).</span>
<span class="sd">            Default is False.</span>
<span class="sd">        transtrum_damping: Float or None, optional</span>
<span class="sd">            If not None, then clips the Marquardt damping diagonal</span>
<span class="sd">            entries to be at least transtrum_damping. Default is None.</span>

<span class="sd">        use_accel: Bool, optional</span>
<span class="sd">            Set to True to incorporate the geodesic acceleration term</span>
<span class="sd">            from M. Transtrum J. Sethna 2012. Default is False.</span>
<span class="sd">        max_accel_correction: Float, optional</span>
<span class="sd">            Acceleration corrections bigger than max_accel_correction times</span>
<span class="sd">            the normal LM step are viewed as bad steps, causing a</span>
<span class="sd">            decrease in damping. Default is 1.0. Only applies to the</span>
<span class="sd">            do_run_1 method.</span>

<span class="sd">        paramtol : Float, optional</span>
<span class="sd">            Algorithm has converged when the none of the parameters have</span>
<span class="sd">            changed by more than paramtol. Default is 1e-6.</span>
<span class="sd">        errtol : Float, optional</span>
<span class="sd">            Algorithm has converged when the error has changed by less</span>
<span class="sd">            than errtol after 1 step. Default is 1e-6.</span>
<span class="sd">        exptol : Float, optional</span>
<span class="sd">            Algorithm has converged when the expected change in error is</span>
<span class="sd">            less than exptol. Default is 1e-3.</span>
<span class="sd">        fractol : Float, optional</span>
<span class="sd">            Algorithm has converged when the error has changed by a</span>
<span class="sd">            fractional amount less than fractol after 1 step.</span>
<span class="sd">            Default is 1e-6.</span>
<span class="sd">        costol : Float, optional</span>
<span class="sd">            Algorithm has converged when the cosine of the angle between</span>
<span class="sd">            (residuals projected onto the model manifold) and (the</span>
<span class="sd">            residuals) is &lt; costol. Default is None, i.e. doesn&#39;t check</span>
<span class="sd">            the cosine (since it takes a bit of time).</span>
<span class="sd">        max_iter : Int, optional</span>
<span class="sd">            The maximum number of iterations before the algorithm</span>
<span class="sd">            stops iterating. Default is 5.</span>

<span class="sd">        update_J_frequency: Int, optional</span>
<span class="sd">            The frequency to re-calculate the full Jacobian matrix.</span>
<span class="sd">            Default is 2, i.e. every other run.</span>
<span class="sd">        broyden_update: Bool, optional</span>
<span class="sd">            Set to True to do a Broyden partial update on J after</span>
<span class="sd">            each step, updating the projection of J along the</span>
<span class="sd">            parameter change direction. Cheap in time cost, but not</span>
<span class="sd">            always accurate. Default is False.</span>
<span class="sd">        eig_update: Bool, optional</span>
<span class="sd">            Set to True to update the projection of J along the most</span>
<span class="sd">            stiff eigendirections of JTJ. Slower than broyden but</span>
<span class="sd">            more accurate &amp; useful. Default is False.</span>
<span class="sd">        num_eig_dirs: Int, optional</span>
<span class="sd">            If eig_update == True, the number of eigendirections to</span>
<span class="sd">            update when doing the eigen update. Default is 4.</span>
<span class="sd">        eig_update_frequency: Int, optional</span>
<span class="sd">            If eig_update, the frequency to do this partial update.</span>
<span class="sd">            Default is 3.</span>
<span class="sd">        broyden_update_frequency: Int, optional</span>
<span class="sd">            If broyden_update, the frequency to do this partial update.</span>
<span class="sd">            Default is 1.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        J : numpy.ndarray</span>
<span class="sd">            The calculated J for Levenberg-Marquardt. Starts as `None`</span>
<span class="sd">        JTJ : numpy.ndarray</span>
<span class="sd">            The approximation to the fit Hessian; np.dot(J, J.T)</span>
<span class="sd">        damping : numpy.ndarray</span>
<span class="sd">            The current damping vector for the parameters.</span>
<span class="sd">        _num_iter : Int</span>
<span class="sd">            The number of iterations ran in the current cycle. Don&#39;t touch</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        reset(new_damping=None)</span>
<span class="sd">            Resets all counters etc so a new run can commence.</span>
<span class="sd">        do_run_1()</span>
<span class="sd">            Method 1 for optimization.</span>
<span class="sd">        do_run_2()</span>
<span class="sd">            Method 2 for optimization</span>
<span class="sd">        do_internal_run()</span>
<span class="sd">            Additional, slight optimization once J has been calculated</span>
<span class="sd">        find_LM_updates(grad, do_correct_damping=True, subblock=None)</span>
<span class="sd">            Returns the Levenberg-Marquardt step.</span>
<span class="sd">        increase_damping()</span>
<span class="sd">            Increases damping</span>
<span class="sd">        decrease_damping(undo_decrease=False)</span>
<span class="sd">            Decreases damping or undoes a previous decrease.</span>
<span class="sd">        update_param_vals(new_vals, incremental=False)</span>
<span class="sd">            Updates the current set of parameter values and previous</span>
<span class="sd">            values, sets a flag to re-calculate J.</span>
<span class="sd">        calc_model_cosine(decimate=None)</span>
<span class="sd">            Calculates the cosine of the residuals with the current</span>
<span class="sd">            model tangent space J</span>
<span class="sd">        get_termination_stats(get_cos=True)</span>
<span class="sd">            Returns a dict of termination statistics</span>
<span class="sd">        check_completion()</span>
<span class="sd">            Checks if the algorithm has found a satisfactory minimum</span>
<span class="sd">        check_termination()</span>
<span class="sd">            Checks if the algorithm should terminate</span>
<span class="sd">        update_J()</span>
<span class="sd">            Updates J, JTJ</span>
<span class="sd">        calc_grad()</span>
<span class="sd">            Calculates the gradient of the cost w.r.t. the parameters.</span>
<span class="sd">        update_Broyden_J()</span>
<span class="sd">            Execute a Broyden update of J</span>
<span class="sd">        update_eig_J()</span>
<span class="sd">            Execute an eigen update of J</span>
<span class="sd">        calc_accel_correction(damped_JTJ, delta0)</span>
<span class="sd">            Calculates the geodesic acceleration correction to the</span>
<span class="sd">            standard Levenberg-Marquardt step.</span>
<span class="sd">        update_select_J(blk)</span>
<span class="sd">            Updates J only for certain parameters, described by the</span>
<span class="sd">            boolean mask `blk`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMFunction : Levenberg-Marquardt (LM) optimization for a user-</span>
<span class="sd">            supplied function.</span>
<span class="sd">        LMGlobals : LM optimization designed for optimizing state globals.</span>
<span class="sd">        LMParticles : LM optimization designed for optimizing state particles.</span>
<span class="sd">        LMParticleGroupCollection : LM optimization on all particles in a</span>
<span class="sd">            state.</span>
<span class="sd">        LMAugmentedState : LMGlobals with additional R(z) parameters.</span>
<span class="sd">        LMOptObj : ...</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There are 3 different options for optimizing:</span>

<span class="sd">    * do_run_1():</span>
<span class="sd">        Checks to calculate full, Broyden, and eigen J, then tries a step.</span>
<span class="sd">        If the step is accepted, decreases damping; if not, increases.</span>
<span class="sd">    * do_run_2():</span>
<span class="sd">        Checks to calculate full, Broyden, and eigen J, then tries a</span>
<span class="sd">        step with the current damping and with a decreased damping,</span>
<span class="sd">        accepting whichever is lower. Decreases damping iff the lower</span>
<span class="sd">        damping is better. It then calls do_internal_run() (see below).</span>
<span class="sd">        Rejected steps result in increased damping until a step is</span>
<span class="sd">        accepted. Checks for full, Broyden, and eigen J updates.</span>
<span class="sd">    * do_internal_run():</span>
<span class="sd">        Checks for Broyden and eigen J updates only, then uses</span>
<span class="sd">        pre-calculated J, JTJ, etc to evaluate LM steps. Does</span>
<span class="sd">        not change damping during the run. Does not check do update</span>
<span class="sd">        the full J, but does check for Broyden, eigen updates.</span>
<span class="sd">        Does not work if J has not been evaluated yet.</span>

<span class="sd">    Whether to update the full J is controlled by update_J_frequency only,</span>
<span class="sd">    which only counts iterations of do_run_1() and do_run_2().</span>
<span class="sd">    Partial updates are controlled by `*_update_frequency`, which</span>
<span class="sd">    counts internal runs in do_internal_run and full runs in do_run_1.</span>

<span class="sd">    So, if you want a partial update every other run, full J the remaining,</span>
<span class="sd">    this would be:</span>

<span class="sd">    * do_run_1(): update_J_frequency=2, partial_update_frequency=1</span>
<span class="sd">    * do_run_2(): update_J_frequency=1, partial_update_frequency=1, run_length=2</span>

<span class="sd">    Partial Updates:</span>

<span class="sd">    * Broyden update  : an update to J (and then JTJ) by approximating the</span>
<span class="sd">        derivative of the model as the finite difference of the last</span>
<span class="sd">        step. (rank-1)</span>

<span class="sd">    * Eigen update    : a rank-num_eig_dirs update to J (and then JTJ) by</span>
<span class="sd">        finite-differencing with eig_dl along the highest num_eig_dirs</span>
<span class="sd">        eigendirections.</span>

<span class="sd">    Damping:</span>

<span class="sd">    * marquardt : Damp proportional to the diagonal elements of JTJ</span>
<span class="sd">    * transtrum : Marquardt damping, clipped to be at least a certain number</span>
<span class="sd">    * default   : (levenberg) Damp using something proportional to the identity</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">        .. [1] M. Transtrum and J. Sethna, &quot;Improvements to the Levenberg-</span>
<span class="sd">            Marquardt algorithm for nonlinear least-squares minimization,&quot;</span>
<span class="sd">            ArXiV preprint arXiv:1201.5885 (2012)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">increase_damp_factor</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="mf">8.</span><span class="p">,</span>
                <span class="n">min_eigval</span><span class="o">=</span><span class="mf">1e-13</span><span class="p">,</span> <span class="n">marquardt_damping</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">transtrum_damping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">use_accel</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_accel_correction</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">paramtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span>
                <span class="n">errtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">exptol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">fractol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">costol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">max_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">update_J_frequency</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">broyden_update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eig_update_frequency</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                <span class="n">num_eig_dirs</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">eig_dl</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">broyden_update_frequency</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">increase_damp_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">increase_damp_factor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damp_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">decrease_damp_factor</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_eigval</span> <span class="o">=</span> <span class="n">min_eigval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marquardt_damping</span> <span class="o">=</span> <span class="n">marquardt_damping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transtrum_damping</span> <span class="o">=</span> <span class="n">transtrum_damping</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">use_accel</span> <span class="o">=</span> <span class="n">use_accel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_accel_correction</span> <span class="o">=</span> <span class="n">max_accel_correction</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">paramtol</span> <span class="o">=</span> <span class="n">paramtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errtol</span> <span class="o">=</span> <span class="n">errtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exptol</span> <span class="o">=</span> <span class="n">exptol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fractol</span> <span class="o">=</span> <span class="n">fractol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">costol</span> <span class="o">=</span> <span class="n">costol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span> <span class="o">=</span> <span class="n">max_iter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_J_frequency</span> <span class="o">=</span> <span class="n">update_J_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broyden_update</span> <span class="o">=</span> <span class="n">broyden_update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_update</span> <span class="o">=</span> <span class="n">eig_update</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_eig_dirs</span> <span class="o">=</span> <span class="n">num_eig_dirs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_length</span> <span class="o">=</span> <span class="n">run_length</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_update_frequency</span> <span class="o">=</span> <span class="n">eig_update_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">broyden_update_frequency</span> <span class="o">=</span> <span class="n">broyden_update_frequency</span>

        <span class="c1">#Initializing counters etc for the first loop:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exp_err</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">exptol</span>

        <span class="c1">#We want to start updating JTJ</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_J_update_counter</span> <span class="o">=</span> <span class="n">update_J_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1">#the max # of times trying to decrease damping before giving up</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_max_inner_loop</span> <span class="o">=</span> <span class="mi">15</span>

        <span class="c1">#Finally we set the error and parameter values:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_err_paramvals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">damping</span><span class="p">)</span>  <span class="c1">#keeping the damping always a vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_run</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eig_dl</span> <span class="o">=</span> <span class="n">eig_dl</span>

<div class="viewcode-block" id="LMEngine.reset"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_damping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keeps all user supplied options the same, but resets counters etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_iter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_J_update_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_J_frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_run</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">new_damping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_damping</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_err_paramvals</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_set_err_paramvals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Must update:</span>
<span class="sd">            self.error, self._last_error, self.param_vals, self._last_vals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;implement in subclass&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="LMEngine.calc_J"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.calc_J">[docs]</a>    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates self.J, returns nothing&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;implement in subclass&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMEngine.calc_residuals"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.calc_residuals">[docs]</a>    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns residuals = data - model.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;implement in subclass&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMEngine.update_function"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.update_function">[docs]</a>    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes an array param_vals, updates function, returns the new error&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;implement in subclass&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMEngine.do_run_1"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.do_run_1">[docs]</a>    <span class="k">def</span> <span class="nf">do_run_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LM run, evaluating 1 step at a time.</span>

<span class="sd">        Broyden or eigendirection updates replace full-J updates until</span>
<span class="sd">        a full-J update occurs. Does not run with the calculated J (no</span>
<span class="sd">        internal run).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_terminate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_run</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_run1</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_iter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">+=</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">_run1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;workhorse for do_run_1&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_update_J</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_J</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_Broyden_J</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_Broyden_J</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_update_eig_J</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_eig_J</span><span class="p">()</span>

        <span class="c1">#1. Assuming that J starts updated:</span>
        <span class="n">delta_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_LM_updates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">())</span>

        <span class="c1">#2. Increase damping until we get a good step:</span>
        <span class="n">er1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_vals</span><span class="p">)</span>
        <span class="n">good_step</span> <span class="o">=</span> <span class="p">(</span><span class="n">find_best_step</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">er1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">good_step</span><span class="p">:</span>
            <span class="n">er0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">er0</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">)</span><span class="o">/</span><span class="n">er0</span> <span class="o">&gt;</span> <span class="mf">1e-7</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Function updates are not exact.&#39;</span><span class="p">)</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Bad step, increasing damping&#39;</span><span class="p">)</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">er1</span><span class="p">))</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">_try</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_inner_loop</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">increase_damping</span><span class="p">()</span>
                <span class="n">delta_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_LM_updates</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                <span class="n">er1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_vals</span><span class="p">)</span>
                <span class="n">good_step</span> <span class="o">=</span> <span class="p">(</span><span class="n">find_best_step</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">er1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">good_step</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">er0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stuck!&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">er0</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">)</span><span class="o">/</span><span class="n">er0</span> <span class="o">&gt;</span> <span class="mf">1e-7</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Function updates are not exact.&#39;</span><span class="p">)</span>

        <span class="c1">#state is updated, now params:</span>
        <span class="k">if</span> <span class="n">good_step</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">er1</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Good step</span><span class="se">\t</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_param_vals</span><span class="p">(</span><span class="n">delta_vals</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damping</span><span class="p">()</span>

<div class="viewcode-block" id="LMEngine.do_run_2"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.do_run_2">[docs]</a>    <span class="k">def</span> <span class="nf">do_run_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        LM run evaluating 2 steps (damped and not) and choosing the best.</span>

<span class="sd">        After finding the best of 2 steps, runs with that damping + Broyden</span>
<span class="sd">        or eigendirection updates, until deciding to do a full-J update.</span>
<span class="sd">        Only changes damping after full-J updates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_terminate</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_run</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_run2</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_iter</span> <span class="o">+=</span> <span class="mi">1</span></div>

    <span class="k">def</span> <span class="nf">_run2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Workhorse for do_run_2&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_update_J</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_J</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_Broyden_J</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_Broyden_J</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_update_eig_J</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_eig_J</span><span class="p">()</span>

        <span class="c1">#0. Find _last_residuals, _last_error, etc:</span>
        <span class="n">_last_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_last_error</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span>
        <span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1">#1. Calculate 2 possible steps</span>
        <span class="n">delta_params_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_LM_updates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">(),</span>
                <span class="n">do_correct_damping</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damping</span><span class="p">()</span>
        <span class="n">delta_params_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_LM_updates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">(),</span>
                <span class="n">do_correct_damping</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damping</span><span class="p">(</span><span class="n">undo_decrease</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1">#2. Check which step is best:</span>
        <span class="n">er1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_params_1</span><span class="p">)</span>
        <span class="n">er2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_params_2</span><span class="p">)</span>

        <span class="n">triplet</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="n">er1</span><span class="p">,</span> <span class="n">er2</span><span class="p">)</span>
        <span class="n">best_step</span> <span class="o">=</span> <span class="n">find_best_step</span><span class="p">(</span><span class="n">triplet</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">best_step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#Both bad steps, put back &amp; increase damping:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">()</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Bad step, increasing damping&#39;</span><span class="p">)</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">triplet</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_try</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_max_inner_loop</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">increase_damping</span><span class="p">()</span>
                <span class="n">delta_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_LM_updates</span><span class="p">(</span><span class="n">grad</span><span class="p">)</span>
                <span class="n">er_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_vals</span><span class="p">)</span>
                <span class="n">good_step</span> <span class="o">=</span> <span class="n">er_new</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>
                <span class="k">if</span> <span class="n">good_step</span><span class="p">:</span>
                    <span class="c1">#Update params, error, break:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_param_vals</span><span class="p">(</span><span class="n">delta_vals</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">er_new</span>
                    <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Sufficiently increased damping&#39;</span><span class="p">)</span>
                    <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">triplet</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1">#for-break-else</span>
                <span class="c1">#Throw a warning, put back the parameters</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Stuck!&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

        <span class="k">elif</span> <span class="n">best_step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#er1 &lt;= er2:</span>
            <span class="n">good_step</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Good step, same damping&#39;</span><span class="p">)</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">triplet</span><span class="p">)</span>
            <span class="c1">#Update to er1 params:</span>
            <span class="n">er1_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_params_1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">er1_1</span> <span class="o">-</span> <span class="n">er1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Function updates are not exact.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_param_vals</span><span class="p">(</span><span class="n">delta_params_1</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">er1</span>

        <span class="k">elif</span> <span class="n">best_step</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#er2 &lt; er1:</span>
            <span class="n">good_step</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">er2</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Good step, decreasing damping&#39;</span><span class="p">)</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">triplet</span><span class="p">)</span>
            <span class="c1">#-we&#39;re already at the correct parameters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_param_vals</span><span class="p">(</span><span class="n">delta_params_2</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damping</span><span class="p">()</span>

        <span class="c1">#3. Run with current J, damping; update what we need to::</span>
        <span class="k">if</span> <span class="n">good_step</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_residuals</span> <span class="o">=</span> <span class="n">_last_residuals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="n">_last_error</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="n">_last_vals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_internal_run</span><span class="p">(</span><span class="n">initial_count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="LMEngine.do_internal_run"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.do_internal_run">[docs]</a>    <span class="k">def</span> <span class="nf">do_internal_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_count</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">update_derr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes more steps without calculating J again.</span>

<span class="sd">        Given a fixed damping, J, JTJ, iterates calculating steps, with</span>
<span class="sd">        optional Broyden or eigendirection updates. Iterates either until</span>
<span class="sd">        a bad step is taken or for self.run_length times.</span>
<span class="sd">        Called internally by do_run_2() but is also useful on its own.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            initial_count : Int, optional</span>
<span class="sd">                The initial count of the run. Default is 0. Increasing from</span>
<span class="sd">                0 effectively temporarily decreases run_length.</span>
<span class="sd">            subblock : None or np.ndarray of bools, optional</span>
<span class="sd">                If not None, a boolean mask which determines which sub-</span>
<span class="sd">                block of parameters to run over. Default is None, i.e.</span>
<span class="sd">                all the parameters.</span>
<span class="sd">            update_derr : Bool, optional</span>
<span class="sd">                Set to False to not update the variable that determines</span>
<span class="sd">                delta_err, preventing premature termination through errtol.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        It might be good to do something similar to update_derr with the</span>
<span class="sd">        parameter values, but this is trickier because of Broyden updates</span>
<span class="sd">        and _fresh_J.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">=</span> <span class="n">initial_count</span><span class="p">;</span> <span class="n">good_step</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">n_good_steps</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running...&#39;</span><span class="p">)</span>

        <span class="n">_last_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">while</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">good_step</span> <span class="o">&amp;</span>
                <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_terminate</span><span class="p">())):</span>
            <span class="c1">#1. Checking if we update J</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_Broyden_J</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_Broyden_J</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_update_eig_J</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_eig_J</span><span class="p">()</span>

            <span class="c1">#2. Getting parameters, error</span>
            <span class="n">er0</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span>
            <span class="n">delta_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_LM_updates</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">(),</span>
                    <span class="n">do_correct_damping</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="n">subblock</span><span class="p">)</span>
            <span class="n">er1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta_vals</span><span class="p">)</span>
            <span class="n">good_step</span> <span class="o">=</span> <span class="n">er1</span> <span class="o">&lt;</span> <span class="n">er0</span>

            <span class="k">if</span> <span class="n">good_step</span><span class="p">:</span>
                <span class="n">n_good_steps</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">er0</span><span class="p">,</span> <span class="n">er1</span><span class="p">))</span>
                <span class="c1">#Updating:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_param_vals</span><span class="p">(</span><span class="n">delta_vals</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_last_residuals</span> <span class="o">=</span> <span class="n">_last_residuals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">update_derr</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="n">er0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">er1</span>

                <span class="n">_last_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">er0_0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Bad step!&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">er0</span> <span class="o">-</span> <span class="n">er0_0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Function updates are not exact.&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n_good_steps</span></div>

    <span class="k">def</span> <span class="nf">_calc_damped_jtj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">JTJ</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">marquardt_damping</span><span class="p">:</span>
            <span class="n">diag_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">JTJ</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">transtrum_damping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">diag_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">JTJ</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">transtrum_damping</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">diag_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">JTJ</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">(</span><span class="n">diag_vals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">subblock</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">damped_JTJ</span> <span class="o">=</span> <span class="n">JTJ</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">damping</span><span class="o">*</span><span class="n">diag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">damped_JTJ</span> <span class="o">=</span> <span class="n">JTJ</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">damping</span><span class="p">[</span><span class="n">subblock</span><span class="p">]</span><span class="o">*</span><span class="n">diag</span>
        <span class="k">return</span> <span class="n">damped_JTJ</span>

<div class="viewcode-block" id="LMEngine.find_LM_updates"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.find_LM_updates">[docs]</a>    <span class="k">def</span> <span class="nf">find_LM_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">do_correct_damping</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates LM updates, with or without the acceleration correction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            grad : numpy.ndarray</span>
<span class="sd">                The gradient of the model cost.</span>
<span class="sd">            do_correct_damping : Bool, optional</span>
<span class="sd">                If `self.use_accel`, then set to True to correct damping</span>
<span class="sd">                if the acceleration correction is too big. Default is True</span>
<span class="sd">                Does nothing is `self.use_accel` is False</span>
<span class="sd">            subblock : slice, numpy.ndarray, or None, optional</span>
<span class="sd">                Set to a slice or a valide numpy.ndarray to use only a</span>
<span class="sd">                certain subset of the parameters. Default is None, i.e.</span>
<span class="sd">                use all the parameters.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            delta : numpy.ndarray</span>
<span class="sd">                The Levenberg-Marquadt step, relative to the old</span>
<span class="sd">                parameters. Size is always self.param_vals.size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">subblock</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">subblock</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">fatal</span><span class="p">(</span><span class="s1">&#39;Empty subblock in find_LM_updates&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Empty sub-block&#39;</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">subblock</span><span class="p">]</span>
            <span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">damped_JTJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_damped_jtj</span><span class="p">(</span><span class="n">JTJ</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="n">subblock</span><span class="p">)</span>
            <span class="n">grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">[</span><span class="n">subblock</span><span class="p">]</span>  <span class="c1">#select the subblock of the grad</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">damped_JTJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_damped_jtj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="n">subblock</span><span class="p">)</span>

        <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_lm_step</span><span class="p">(</span><span class="n">damped_JTJ</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="n">subblock</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_accel</span><span class="p">:</span>
            <span class="n">accel_correction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_accel_correction</span><span class="p">(</span><span class="n">damped_JTJ</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
            <span class="n">nrm_d0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">delta</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">nrm_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">accel_correction</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;|correction| / |LM step|</span><span class="se">\t</span><span class="si">%e</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrm_corr</span><span class="o">/</span><span class="n">nrm_d0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">nrm_corr</span><span class="o">/</span><span class="n">nrm_d0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_accel_correction</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">+=</span> <span class="n">accel_correction</span>
            <span class="k">elif</span> <span class="n">do_correct_damping</span><span class="p">:</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Untrustworthy step! Increasing damping...&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">increase_damping</span><span class="p">()</span>
                <span class="n">damped_JTJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_damped_jtj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="n">subblock</span><span class="p">)</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_lm_step</span><span class="p">(</span><span class="n">damped_JTJ</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="n">subblock</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">delta</span><span class="p">)):</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">fatal</span><span class="p">(</span><span class="s1">&#39;Calculated steps have nans!?&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;Calculated steps have nans!?&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">delta</span></div>

    <span class="k">def</span> <span class="nf">_calc_lm_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">damped_JTJ</span><span class="p">,</span> <span class="n">grad</span><span class="p">,</span> <span class="n">subblock</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates a Levenberg-Marquard step w/o acceleration&quot;&quot;&quot;</span>
        <span class="n">delta0</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">damped_JTJ</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">grad</span><span class="p">,</span>
                <span class="n">rcond</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_eigval</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span><span class="p">:</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> degenerate of </span><span class="si">%d</span><span class="s1"> total directions&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">delta0</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="n">rank</span><span class="p">,</span> <span class="n">delta0</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">subblock</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">delta</span><span class="p">[</span><span class="n">subblock</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delta</span> <span class="o">=</span> <span class="n">delta0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">delta</span>

    <span class="k">def</span> <span class="nf">increase_damping</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">increase_damp_factor</span>

    <span class="k">def</span> <span class="nf">decrease_damping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">undo_decrease</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">undo_decrease</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damp_factor</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">damping</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decrease_damp_factor</span>

<div class="viewcode-block" id="LMEngine.update_param_vals"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.update_param_vals">[docs]</a>    <span class="k">def</span> <span class="nf">update_param_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_vals</span><span class="p">,</span> <span class="n">incremental</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the current set of parameter values and previous values,</span>
<span class="sd">        sets a flag to re-calculate J.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            new_vals : numpy.ndarray</span>
<span class="sd">                The new values to update to</span>
<span class="sd">            incremental : Bool, optional</span>
<span class="sd">                Set to True to make it an incremental update relative</span>
<span class="sd">                to the old parameters. Default is False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">incremental</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+=</span> <span class="n">new_vals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">new_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1">#And we&#39;ve updated, so JTJ is no longer valid:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="LMEngine.find_expected_error"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.find_expected_error">[docs]</a>    <span class="k">def</span> <span class="nf">find_expected_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_params</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the error expected after an update if the model were linear.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            delta_params : {numpy.ndarray, &#39;calc&#39;, or &#39;perfect&#39;}, optional</span>
<span class="sd">                The relative change in parameters. If &#39;calc&#39;, uses update</span>
<span class="sd">                calculated from the current damping, J, etc; if &#39;perfect&#39;,</span>
<span class="sd">                uses the update calculated with zero damping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            numpy.float64</span>
<span class="sd">                The expected error after the update with `delta_params`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">delta_params</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="s1">&#39;calc&#39;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="s1">&#39;perfect&#39;</span><span class="p">)]:</span>
            <span class="n">jtj</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span> <span class="k">if</span> <span class="n">delta_params</span> <span class="o">==</span> <span class="s1">&#39;perfect&#39;</span> <span class="k">else</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_calc_damped_jtj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">))</span>
            <span class="n">delta_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_lm_step</span><span class="p">(</span><span class="n">jtj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_grad</span><span class="p">())</span>
        <span class="c1">#If the model were linear, then the cost would be quadratic,</span>
        <span class="c1">#with Hessian 2*`self.JTJ` and gradient `grad`</span>
        <span class="n">expected_error</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">delta_params</span><span class="p">)</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">,</span> <span class="n">delta_params</span><span class="p">),</span> <span class="n">delta_params</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">expected_error</span></div>

<div class="viewcode-block" id="LMEngine.calc_model_cosine"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.calc_model_cosine">[docs]</a>    <span class="k">def</span> <span class="nf">calc_model_cosine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;err&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the cosine of the residuals with the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            decimate : Int or None, optional</span>
<span class="sd">                Decimate the residuals by `decimate` pixels. If None, no</span>
<span class="sd">                decimation is used. Valid only with mode=&#39;svd&#39;. Default</span>
<span class="sd">                is None</span>
<span class="sd">            mode : {&#39;svd&#39;, &#39;err&#39;}</span>
<span class="sd">                Which mode to use; see Notes section. Default is &#39;err&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            abs_cos : numpy.float64</span>
<span class="sd">                The absolute value of the model cosine.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The model cosine is defined in terms of the geometric view of</span>
<span class="sd">        curve-fitting, as a model manifold embedded in a high-dimensional</span>
<span class="sd">        space. The model cosine is the cosine of the residuals vector</span>
<span class="sd">        with its projection on the tangent space: :math:`cos(phi) = |P^T r|/|r|`</span>
<span class="sd">        where :math:`P^T` is the projection operator onto the model manifold</span>
<span class="sd">        and :math:`r` the residuals. This can be calculated two ways: By</span>
<span class="sd">        calculating the projection operator P directly with SVD (mode=`svd`),</span>
<span class="sd">        or by using the expected error if the model were linear to calculate</span>
<span class="sd">        a model sine first (mode=`err`). Since the SVD of a large matrix is</span>
<span class="sd">        slow, mode=`err` is faster.</span>

<span class="sd">        `decimate` allows for every nth pixel only to be counted in the</span>
<span class="sd">        SVD matrix of J for speed. While this is n x faster, it is</span>
<span class="sd">        considerably less accurate, so the default is no decimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;svd&#39;</span><span class="p">:</span>
            <span class="n">slicer</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">decimate</span><span class="p">)</span>

            <span class="c1">#1. Calculate projection term</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[:,</span><span class="n">slicer</span><span class="p">],</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#slow part</span>
            <span class="c1"># p = np.dot(v.T, v) - memory error, so term-by-term</span>
            <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()[</span><span class="n">slicer</span><span class="p">]</span>
            <span class="n">abs_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>

            <span class="n">v_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">r</span><span class="o">/</span><span class="n">abs_r</span><span class="p">)</span>
            <span class="n">projected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v_r</span><span class="p">)</span>

            <span class="n">abs_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">projected</span><span class="o">*</span><span class="n">projected</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span>
            <span class="n">expected_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_expected_error</span><span class="p">(</span><span class="n">delta_params</span><span class="o">=</span><span class="s1">&#39;perfect&#39;</span><span class="p">)</span>
            <span class="n">model_sine_2</span> <span class="o">=</span> <span class="n">expected_error</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>  <span class="c1">#error = distance^2</span>
            <span class="n">abs_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">model_sine_2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mode must be one of `svd`, `err`&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">abs_cos</span></div>

<div class="viewcode-block" id="LMEngine.get_termination_stats"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.get_termination_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_termination_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">get_cos</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dict of termination statistics</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            get_cos : Bool, optional</span>
<span class="sd">                Whether or not to calcualte the cosine of the residuals</span>
<span class="sd">                with the tangent plane of the model using the current J.</span>
<span class="sd">                The calculation may take some time. Default is True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            dict</span>
<span class="sd">                Has keys</span>
<span class="sd">                    delta_vals  : The last change in parameter values.</span>
<span class="sd">                    delta_err   : The last change in the error.</span>
<span class="sd">                    exp_err     : The expected (last) change in the error.</span>
<span class="sd">                    frac_err    : The fractional change in the error.</span>
<span class="sd">                    num_iter    : The number of iterations completed.</span>
<span class="sd">                    error       : The current error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">delta_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span>
        <span class="n">delta_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>
        <span class="n">frac_err</span> <span class="o">=</span> <span class="n">delta_err</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>
        <span class="n">to_return</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;delta_vals&#39;</span><span class="p">:</span><span class="n">delta_vals</span><span class="p">,</span> <span class="s1">&#39;delta_err&#39;</span><span class="p">:</span><span class="n">delta_err</span><span class="p">,</span>
                <span class="s1">&#39;num_iter&#39;</span><span class="p">:</span><span class="mi">1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_iter</span><span class="p">,</span> <span class="s1">&#39;frac_err&#39;</span><span class="p">:</span><span class="n">frac_err</span><span class="p">,</span>
                <span class="s1">&#39;error&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">,</span> <span class="s1">&#39;exp_err&#39;</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_exp_err</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">get_cos</span><span class="p">:</span>
            <span class="n">model_cosine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_model_cosine</span><span class="p">()</span>
            <span class="n">to_return</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;model_cosine&#39;</span><span class="p">:</span><span class="n">model_cosine</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">to_return</span></div>

<div class="viewcode-block" id="LMEngine.check_completion"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.check_completion">[docs]</a>    <span class="k">def</span> <span class="nf">check_completion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Bool of whether the algorithm has found a satisfactory minimum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">terminate</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">term_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_termination_stats</span><span class="p">(</span><span class="n">get_cos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">costol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">terminate</span> <span class="o">|=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">term_dict</span><span class="p">[</span><span class="s1">&#39;delta_vals&#39;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">paramtol</span><span class="p">)</span>
        <span class="n">terminate</span> <span class="o">|=</span> <span class="p">(</span><span class="n">term_dict</span><span class="p">[</span><span class="s1">&#39;delta_err&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">errtol</span><span class="p">)</span>
        <span class="n">terminate</span> <span class="o">|=</span> <span class="p">(</span><span class="n">term_dict</span><span class="p">[</span><span class="s1">&#39;exp_err&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">exptol</span><span class="p">)</span>
        <span class="n">terminate</span> <span class="o">|=</span> <span class="p">(</span><span class="n">term_dict</span><span class="p">[</span><span class="s1">&#39;frac_err&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">fractol</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">costol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">terminate</span> <span class="o">|=</span> <span class="p">(</span><span class="n">curcos</span> <span class="o">&lt;</span> <span class="n">term_dict</span><span class="p">[</span><span class="s1">&#39;model_cosine&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">terminate</span></div>

<div class="viewcode-block" id="LMEngine.check_terminate"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.check_terminate">[docs]</a>    <span class="k">def</span> <span class="nf">check_terminate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a Bool of whether to terminate.</span>

<span class="sd">        Checks whether a satisfactory minimum has been found or whether</span>
<span class="sd">        too many iterations have occurred.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_run</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#1-3. errtol, paramtol, model cosine low enough?</span>
            <span class="n">terminate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_completion</span><span class="p">()</span>

            <span class="c1">#4. too many iterations??</span>
            <span class="n">terminate</span> <span class="o">|=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_iter</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_iter</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">terminate</span></div>

<div class="viewcode-block" id="LMEngine.check_update_J"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.check_update_J">[docs]</a>    <span class="k">def</span> <span class="nf">check_update_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if the full J should be updated.</span>

<span class="sd">        Right now, just updates after update_J_frequency loops</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_J_update_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_J_update_counter</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_J_frequency</span>
        <span class="k">return</span> <span class="n">update</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMEngine.update_J"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.update_J">[docs]</a>    <span class="k">def</span> <span class="nf">update_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates J, JTJ, and internal counters.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">calc_J</span><span class="p">()</span>
        <span class="c1"># np.dot(j, j.T) is slightly faster but 2x as much mem</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1e-2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>  <span class="c1"># 1% more mem...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span> <span class="o">=</span> <span class="n">low_mem_sq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">)</span>
        <span class="c1">#copies still, since J is not C -ordered but a slice of j_e...</span>
        <span class="c1">#doing self.J.copy() works but takes 2x as much ram..</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_J_update_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;J, JTJ have nans.&#39;</span><span class="p">)</span>
        <span class="c1">#Update self._exp_err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_exp_err</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_expected_error</span><span class="p">(</span><span class="n">delta_params</span><span class="o">=</span><span class="s1">&#39;perfect&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMEngine.calc_grad"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.calc_grad">[docs]</a>    <span class="k">def</span> <span class="nf">calc_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The gradient of the cost w.r.t. the parameters.&quot;&quot;&quot;</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">residuals</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_rank_1_J_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does J += np.outer(direction, new_values - old_values) without</span>
<span class="sd">        using lots of memory</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vals_to_sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">)</span>
        <span class="n">delta_vals</span> <span class="o">=</span> <span class="n">values</span> <span class="o">-</span> <span class="n">vals_to_sub</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">direction</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="n">direction</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta_vals</span>

    <span class="k">def</span> <span class="nf">check_Broyden_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">do_update</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">broyden_update</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">broyden_update_frequency</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">do_update</span>

<div class="viewcode-block" id="LMEngine.update_Broyden_J"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.update_Broyden_J">[docs]</a>    <span class="k">def</span> <span class="nf">update_Broyden_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a Broyden update of J&quot;&quot;&quot;</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Broyden update.&#39;</span><span class="p">)</span>
        <span class="n">delta_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span>
        <span class="n">delta_residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_residuals</span>
        <span class="n">nrm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">delta_vals</span><span class="p">,</span> <span class="n">delta_vals</span><span class="p">))</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">delta_vals</span> <span class="o">/</span> <span class="n">nrm</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">delta_residuals</span> <span class="o">/</span> <span class="n">nrm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rank_1_J_update</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">check_update_eig_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">do_update</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_update</span> <span class="o">&amp;</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span><span class="p">)</span> <span class="o">&amp;</span>
                <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_inner_run_counter</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_update_frequency</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">do_update</span>

<div class="viewcode-block" id="LMEngine.update_eig_J"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.update_eig_J">[docs]</a>    <span class="k">def</span> <span class="nf">update_eig_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute an eigen update of J&quot;&quot;&quot;</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Eigen update.&#39;</span><span class="p">)</span>
        <span class="n">vls</span><span class="p">,</span> <span class="n">vcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">)</span>
        <span class="n">res0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">num_eig_dirs</span><span class="p">,</span> <span class="n">vls</span><span class="o">.</span><span class="n">size</span><span class="p">])):</span>
            <span class="c1">#1. Finding stiff directions</span>
            <span class="n">stif_dir</span> <span class="o">=</span> <span class="n">vcs</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="c1">#already normalized</span>

            <span class="c1">#2. Evaluating derivative along that direction, we&#39;ll use dl=5e-4:</span>
            <span class="n">dl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_dl</span> <span class="c1">#1e-5</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">dl</span><span class="o">*</span><span class="n">stif_dir</span><span class="p">)</span>
            <span class="n">res1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span>

            <span class="c1">#3. Updating</span>
            <span class="n">grad_stif</span> <span class="o">=</span> <span class="p">(</span><span class="n">res1</span><span class="o">-</span><span class="n">res0</span><span class="p">)</span><span class="o">/</span><span class="n">dl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank_1_J_update</span><span class="p">(</span><span class="n">stif_dir</span><span class="p">,</span> <span class="n">grad_stif</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1">#Putting the parameters back:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMEngine.calc_accel_correction"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.calc_accel_correction">[docs]</a>    <span class="k">def</span> <span class="nf">calc_accel_correction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">damped_JTJ</span><span class="p">,</span> <span class="n">delta0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Geodesic acceleration correction to the LM step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            damped_JTJ : numpy.ndarray</span>
<span class="sd">                The damped JTJ used to calculate the initial step.</span>
<span class="sd">            delta0 : numpy.ndarray</span>
<span class="sd">                The initial LM step.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            corr : numpy.ndarray</span>
<span class="sd">                The correction to the original LM step.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Get the derivative:</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
        <span class="n">rm0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">delta0</span><span class="p">)</span>
        <span class="n">rm1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">-</span> <span class="n">delta0</span><span class="p">)</span>
        <span class="n">rm2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">der2</span> <span class="o">=</span> <span class="p">(</span><span class="n">rm2</span> <span class="o">+</span> <span class="n">rm1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">rm0</span><span class="p">)</span>

        <span class="n">corr</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">damped_JTJ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">der2</span><span class="p">),</span>
                <span class="n">rcond</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_eigval</span><span class="p">)</span>
        <span class="n">corr</span> <span class="o">*=</span> <span class="o">-</span><span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">corr</span></div>

<div class="viewcode-block" id="LMEngine.update_select_J"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMEngine.update_select_J">[docs]</a>    <span class="k">def</span> <span class="nf">update_select_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blk</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates J only for certain parameters, described by the boolean</span>
<span class="sd">        mask `blk`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>  <span class="c1">#in case things are not put back...</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">blk_J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">blk</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">dl</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eig_dl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">dl</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">blk_J</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r1</span><span class="o">-</span><span class="n">r0</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">eig_dl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">blk</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">blk_J</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="c1">#Then we also need to update JTJ:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;J, JTJ have nans.&#39;</span><span class="p">)</span></div></div>

<span class="k">class</span> <span class="nc">LMFunction</span><span class="p">(</span><span class="n">LMEngine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt optimization for a user-supplied function.</span>

<span class="sd">    Contains alll the options from the M. Transtrum J. Sethna 2012 ArXiV</span>
<span class="sd">    paper. See LMEngine for further documentation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        data : N-element numpy.ndarray</span>
<span class="sd">            The measured data to fit.</span>
<span class="sd">        func : Function</span>
<span class="sd">            The function to evaluate. Syntax must be</span>
<span class="sd">            ``func(param_values, *func_args, **func_kwargs)``, and return</span>
<span class="sd">            a numpy.ndarray of the same shape as data</span>
<span class="sd">        p0 : P-elemnet numpy.ndarray</span>
<span class="sd">            Float array of the initial parameter guess.</span>
<span class="sd">        dl : Float or P-element numpy.ndarray, optional</span>
<span class="sd">            The dl used for finite-difference derivatives, i.e.</span>
<span class="sd">            ``(f(x+dl[i])) - f(x)) / (dl[i])`` in each direction. If dl</span>
<span class="sd">            is a scalar, it is transformed internally to a list. Default</span>
<span class="sd">            is 1e-8.</span>
<span class="sd">        func_args : List-like, optional</span>
<span class="sd">            Extra ``*args`` to pass to the function. Default is ()</span>
<span class="sd">        func_kargs : Dictionary, optional</span>
<span class="sd">            Extra ``**kwargs`` to pass to the function. Default is {}</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        Any keyword args passed to LMEngine.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        param_vals : numpy.ndarray</span>
<span class="sd">            The current best-fit parameter values of the function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">func_args</span><span class="o">=</span><span class="p">(),</span> <span class="n">func_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">dl</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_args</span> <span class="o">=</span> <span class="n">func_args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span> <span class="o">=</span> <span class="n">func_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">p0</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span> <span class="o">*</span> <span class="n">dl</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dl</span> <span class="o">=</span> <span class="n">npj</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dl</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LMFunction</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_err_paramvals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Must update:</span>
<span class="sd">            self.error, self._last_error, self.param_vals, self._last_vals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># self.param_vals = p0 #sloppy...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fractol</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates self.J, returns nothing&quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">dp</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dl</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">+</span> <span class="n">dp</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span><span class="p">)</span>
            <span class="n">grad_func</span> <span class="o">=</span> <span class="p">(</span><span class="n">f1</span> <span class="o">-</span> <span class="n">f0</span><span class="p">)</span> <span class="o">/</span> <span class="n">dp</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="c1">#J = grad(residuals) = -grad(model)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">grad_func</span>

    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Takes an array param_vals, updates function, returns the new error&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="n">param_vals</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">func_args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">func_kwargs</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span> <span class="c1">#faster for large arrays than (d*d).sum()</span>

<span class="k">class</span> <span class="nc">LMOptObj</span><span class="p">(</span><span class="n">LMEngine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt optimization on an OptObj instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        opt_obj : OptObj or daughter instance</span>
<span class="sd">            The OptObj to optimize.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    -------------------</span>
<span class="sd">        Any kwargs for LMEngine.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        _set_err_paramvals()</span>
<span class="sd">            Helps initialize the LMEngine.</span>
<span class="sd">        calc_J()</span>
<span class="sd">        calc_residuals()</span>
<span class="sd">        update_function()</span>
<span class="sd">            Updates the opt_obj, returns new error.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMEngine</span>
<span class="sd">        OptObj</span>
<span class="sd">        OptState</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Uses an OptObj instance.... should be the syntax for all LMEngine objects?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opt_obj</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span> <span class="o">=</span> <span class="n">opt_obj</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LMOptObj</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_err_paramvals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span><span class="o">.</span><span class="n">get_error</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fractol</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">errtol</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span><span class="o">.</span><span class="n">calc_J</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the opt_obj, returns new error.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="n">param_vals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt_obj</span><span class="o">.</span><span class="n">get_error</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">OptObj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Basically an empty class; just laying out the structure for any daughters.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">param_vals</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1">#@property?</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">None</span>

<span class="k">class</span> <span class="nc">OptState</span><span class="p">(</span><span class="n">OptObj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper for a :class:`peri.states.State` instance which allows for</span>
<span class="sd">    optimization along any set of directions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        state : :class:`peri.states.State`</span>
<span class="sd">            The state to optimize</span>
<span class="sd">        directions : numpy.ndarray</span>
<span class="sd">            [M,N] element array of the M tangent vectors determining</span>
<span class="sd">            the plane, each with N dimensions.</span>
<span class="sd">        p0 : numpy.ndarray or None, optional</span>
<span class="sd">            The optimization is done on a hyperplane spanned by the</span>
<span class="sd">            tangent vectors `directions` and passing through the point</span>
<span class="sd">            `p0`. If `p0` is `None`, then `p0` is set to the current</span>
<span class="sd">            state parameters. Default is None</span>
<span class="sd">        dl : Float, optional</span>
<span class="sd">            The step size for finite-differencing the derivative. Default</span>
<span class="sd">            is 1e-7</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        param_vals : numpy.ndarray</span>
<span class="sd">            The parameter values of the distance moved from `p0` along</span>
<span class="sd">            each of the tangent vectors.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        update_function(param_vals)</span>
<span class="sd">            Update the state to `param_vals` on the hyperplane</span>
<span class="sd">        get_error()</span>
<span class="sd">            Returns self.state.error</span>
<span class="sd">        calc_residuals()</span>
<span class="sd">            Returns self.state.residuals.ravel()</span>
<span class="sd">        calc_J()</span>
<span class="sd">            Calculates J for the state as parameterized by the directions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMOptObj</span>
<span class="sd">        do_levmarq_n_directions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#FIXME should have an allowed set of params, and then R(z) etc</span>
    <span class="c1">#parameterizations should be incorporated into this to eliminate</span>
    <span class="c1">#AugmentedState (or turn it into a subclass)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dl</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dl</span> <span class="o">=</span> <span class="n">dl</span>
        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">params</span><span class="p">])</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p0</span> <span class="o">=</span> <span class="n">p0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">params</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;direction must have same # of elements as state.size&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">directions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates with param_vals[i] = distance from self.p0 along self.direction[i].&quot;&quot;&quot;</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p0</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">dp</span> <span class="o">+=</span> <span class="n">param_vals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p0</span> <span class="o">+</span> <span class="n">dp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">param_vals</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>

    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`peri.state.States.residuals`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates J along the direction.&quot;&quot;&quot;</span>
        <span class="n">r0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">J</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">dl</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="n">dl</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="n">p0</span> <span class="o">+</span> <span class="n">dl</span><span class="p">)</span>
            <span class="n">r1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">(</span><span class="n">r1</span><span class="o">-</span><span class="n">r0</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">dl</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

<div class="viewcode-block" id="LMGlobals"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMGlobals">[docs]</a><span class="k">class</span> <span class="nc">LMGlobals</span><span class="p">(</span><span class="n">LMEngine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt, optimized for state globals.</span>

<span class="sd">    Contains alll the options from the M. Transtrum J. Sethna 2012 ArXiV</span>
<span class="sd">    paper. See LMEngine for further documentation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        state : :class:`peri.states.State`</span>
<span class="sd">            The state to optimize. Stored as self.state.</span>
<span class="sd">        param_names : List</span>
<span class="sd">            List of the parameter names (strings) to optimize over. Stored</span>
<span class="sd">            as self.param_names.</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum memory to use for the optimization; controls pixel</span>
<span class="sd">            decimation. Default is 1e9. Stored as self.max_mem</span>
<span class="sd">        opt_kwargs : Dict, optional</span>
<span class="sd">            Dict of ``**kwargs`` for opt implementation. Right now only for</span>
<span class="sd">            get_num_px_jtj, i.e. keys of &#39;decimate&#39;, &#39;min_redundant&#39;.</span>
<span class="sd">            Default is `{}`. Stored as self.opt_kwargs</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        num_pix : Int</span>
<span class="sd">            The number of pixels of the residuals used to calculate J.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        set_params(new_param_names, new_damping=None)</span>
<span class="sd">            Change the parameter names to optimize.</span>
<span class="sd">        reset(new_damping=None)</span>
<span class="sd">            Resets counters etc to zero, allowing more runs to commence.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMEngine : Parent class for all Levenberg-Marquardt (LM) optimization</span>
<span class="sd">        LMParticles : LM optimization designed for optimizing state particles.</span>
<span class="sd">        LMParticleGroupCollection : LM optimization on all particles in a</span>
<span class="sd">            state.</span>
<span class="sd">        LMAugmentedState : LMGlobals with additional R(z) parameters.</span>
<span class="sd">        do_levmarq : Convenience function for LMGlobals</span>
<span class="sd">        do_levmarq_particles : Convenience function for optimizing particles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">opt_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_kwargs</span> <span class="o">=</span> <span class="n">opt_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="n">max_mem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_pix</span> <span class="o">=</span> <span class="n">get_num_px_jtj</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">),</span> <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">,</span>
                <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LMGlobals</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_err_paramvals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fractol</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span>
        <span class="c1"># self.J, self._inds = get_rand_Japprox(self.state,</span>
                <span class="c1"># self.param_names, num_inds=self.num_pix)</span>
        <span class="n">je</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inds</span> <span class="o">=</span> <span class="n">get_rand_Japprox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span>
                <span class="n">num_inds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_pix</span><span class="p">,</span> <span class="n">include_cost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">je</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#Storing the _direction_ of the exact gradient of the model, rescaled</span>
        <span class="c1">#as to the size we expect from the inds:</span>
        <span class="n">rescale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graderr</span> <span class="o">=</span> <span class="n">je</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">rescale</span>

    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;state update caused nans in residuals&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>

    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_param_names</span><span class="p">,</span> <span class="n">new_damping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">new_param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_err_paramvals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new_damping</span><span class="o">=</span><span class="n">new_damping</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_select_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blk</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates J only for certain parameters, described by the boolean</span>
<span class="sd">        mask blk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)[</span><span class="n">blk</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">blk_J</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">gradmodel</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">inds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_inds</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">blk</span><span class="p">]</span> <span class="o">=</span> <span class="n">blk_J</span>
        <span class="c1">#Then we also need to update JTJ:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">JTJ</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;J, JTJ have nans.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">find_expected_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_params</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">,</span> <span class="n">adjust</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the error expected after an update if the model were linear.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            delta_params : {numpy.ndarray, &#39;calc&#39;, or &#39;perfect&#39;}, optional</span>
<span class="sd">                The relative change in parameters. If &#39;calc&#39;, uses update</span>
<span class="sd">                calculated from the current damping, J, etc; if &#39;perfect&#39;,</span>
<span class="sd">                uses the update calculated with zero damping.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            numpy.float64</span>
<span class="sd">                The expected error after the update with `delta_params`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_error</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">LMGlobals</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">find_expected_error</span><span class="p">(</span>
                <span class="n">delta_params</span><span class="o">=</span><span class="n">delta_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">adjust</span><span class="p">:</span>
            <span class="c1">#adjust for num_pix</span>
            <span class="n">derr</span> <span class="o">=</span> <span class="p">(</span><span class="n">expected_error</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span>
                    <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_pix</span><span class="p">))</span>
            <span class="n">expected_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">+</span> <span class="n">derr</span>
        <span class="k">return</span> <span class="n">expected_error</span>

    <span class="k">def</span> <span class="nf">calc_model_cosine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;err&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the cosine of the residuals with the model.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            decimate : Int or None, optional</span>
<span class="sd">                Decimate the residuals by `decimate` pixels. If None, no</span>
<span class="sd">                decimation is used. Valid only with mode=&#39;svd&#39;. Default</span>
<span class="sd">                is None</span>
<span class="sd">            mode : {&#39;svd&#39;, &#39;err&#39;}</span>
<span class="sd">                Which mode to use; see Notes section. Default is &#39;err&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            abs_cos : numpy.float64</span>
<span class="sd">                The absolute value of the model cosine.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The model cosine is defined in terms of the geometric view of</span>
<span class="sd">        curve-fitting, as a model manifold embedded in a high-dimensional</span>
<span class="sd">        space. The model cosine is the cosine of the residuals vector</span>
<span class="sd">        with its projection on the tangent space: :math:`cos(phi) = |P^T r|/|r|`</span>
<span class="sd">        where :math:`P^T` is the projection operator onto the model manifold</span>
<span class="sd">        and :math:`r` the residuals. This can be calculated two ways: By</span>
<span class="sd">        calculating the projection operator P directly with SVD (mode=`svd`),</span>
<span class="sd">        or by using the expected error if the model were linear to calculate</span>
<span class="sd">        a model sine first (mode=`err`). Since the SVD of a large matrix is</span>
<span class="sd">        slow, mode=`err` is faster.</span>

<span class="sd">        `decimate` allows for every nth pixel only to be counted in the</span>
<span class="sd">        SVD matrix of J for speed. While this is n x faster, it is</span>
<span class="sd">        considerably less accurate, so the default is no decimation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#we calculate the model cosine only in the data space of the</span>
        <span class="c1">#sampled indices</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;err&#39;</span><span class="p">:</span>
            <span class="n">expected_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_expected_error</span><span class="p">(</span><span class="n">delta_params</span><span class="o">=</span><span class="s1">&#39;perfect&#39;</span><span class="p">,</span>
                    <span class="n">adjust</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">derr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">-</span> <span class="n">expected_error</span>
            <span class="n">residuals_err</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">current_partial_error</span> <span class="o">=</span> <span class="n">residuals_err</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">())</span>
            <span class="n">expected_partial_error</span> <span class="o">=</span> <span class="n">current_partial_error</span> <span class="o">-</span> <span class="n">derr</span>
            <span class="n">model_sine_2</span> <span class="o">=</span> <span class="n">expected_partial_error</span> <span class="o">/</span> <span class="n">current_partial_error</span>
            <span class="n">abs_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">model_sine_2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#superclass is fine</span>
            <span class="n">abs_cos</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">calc_model_cosine</span><span class="p">(</span><span class="n">decimate</span><span class="o">=</span>
                    <span class="n">decimate</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">abs_cos</span>

    <span class="k">def</span> <span class="nf">calc_grad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The gradient of the cost w.r.t. the parameters.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_JTJ</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_graderr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">residuals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_residuals</span><span class="p">()</span>
            <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">residuals</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMParticles"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMParticles">[docs]</a><span class="k">class</span> <span class="nc">LMParticles</span><span class="p">(</span><span class="n">LMEngine</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt, optimized for state globals.</span>

<span class="sd">    Contains alll the options from the M. Transtrum J. Sethna 2012 ArXiV</span>
<span class="sd">    paper. See LMEngine for further documentation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        state : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to optimize</span>
<span class="sd">        particles : numpy.ndarray</span>
<span class="sd">            Array of the particle indices to optimize over.</span>
<span class="sd">        include_rad : Bool, optional</span>
<span class="sd">            Whether or not to include the particle radii in the</span>
<span class="sd">            optimization. Default is True</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        param_names : List</span>
<span class="sd">            The list of the parameter names being optimized.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        set_particles(new_particles, new_damping=None)</span>
<span class="sd">            Change the particle to optimize.</span>
<span class="sd">        reset(new_damping=None)</span>
<span class="sd">            Resets counters etc to zero, allowing more runs to commence.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMEngine : Parent class for all Levenberg-Marquardt (LM) optimization</span>
<span class="sd">        LMGlobals : LM optimization designed for optimizing state global</span>
<span class="sd">            parameters.</span>
<span class="sd">        LMParticleGroupCollection : LM optimization on all particles in a</span>
<span class="sd">            state.</span>
<span class="sd">        LMAugmentedState : LMGlobals with additional R(z) parameters.</span>
<span class="sd">        do_levmarq : Convenience function for LMGlobals</span>
<span class="sd">        do_levmarq_particles : Convenience function for optimizing particles</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To prevent the state updates from breaking, this clips the particle</span>
<span class="sd">    rads to [self._MINRAD, self._MAXRAD] and the positions to at least</span>
<span class="sd">    self._MINDIST from the edge of the padded image. These are:</span>
<span class="sd">    * ``_MINRAD``  : 1e-3</span>
<span class="sd">    * ``_MAXRAD``  : 2e2</span>
<span class="sd">    * ``_MINDIST`` : 1e-3</span>
<span class="sd">    For extremely large particles (e.g. larger than _MAXRAD or larger than</span>
<span class="sd">    the pad and barely overlapping the image) these numbers might be</span>
<span class="sd">    insufficient.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">particles</span><span class="p">,</span> <span class="n">include_rad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Empty list of particle indices&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="n">particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">param_particle</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span> <span class="k">if</span> <span class="n">include_rad</span>
                <span class="k">else</span> <span class="n">state</span><span class="o">.</span><span class="n">param_particle_pos</span><span class="p">(</span><span class="n">particles</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diftile</span><span class="p">()</span>
        <span class="c1">#Max, min rads, distance from edge for allowed updates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_MINRAD</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_MAXRAD</span> <span class="o">=</span> <span class="mf">2e2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_MINDIST</span><span class="o">=</span> <span class="mf">1e-3</span>

        <span class="c1">#is_rad, is_pos masks:</span>
        <span class="n">rad_nms</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">param_radii</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="n">include_rad</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="s1">&#39;param_radii&#39;</span><span class="p">))</span> <span class="k">else</span> <span class="p">[])</span>  <span class="c1"># FIXME explicit rad</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span> <span class="ow">in</span> <span class="n">rad_nms</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">])</span>
        <span class="n">pos_nms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">param_positions</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>  <span class="c1"># FIXME explicit 3D</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_pos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">pos_nms</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;zyx&#39;</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">]))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LMParticles</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_diftile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">])</span>
        <span class="n">itile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">get_update_io_tiles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">vals</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">get_residuals_update_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">itile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_err_paramvals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fractol</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diftile</span><span class="p">()</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span>
        <span class="c1">#J = grad(residuals) = -grad(model)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span><span class="o">.</span><span class="n">volume</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">gradmodel</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">rts</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">slicer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span><span class="o">.</span><span class="n">slicer</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">calc_residuals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span><span class="o">.</span><span class="n">volume</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span><span class="o">.</span><span class="n">slicer</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="c1">#1. Clipping values:</span>
        <span class="n">values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_rad</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_rad</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MINRAD</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_MAXRAD</span><span class="p">)</span>
        <span class="n">pd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">pad</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>  <span class="c1"># FIXME explicit 3D</span>
            <span class="n">values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_pos</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_pos</span><span class="p">[</span><span class="n">a</span><span class="p">]],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_MINDIST</span> <span class="o">-</span> <span class="n">pd</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">ishape</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span>
                    <span class="n">pd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MINDIST</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;state update caused nans in residuals&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>

    <span class="k">def</span> <span class="nf">set_particles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_particles</span><span class="p">,</span> <span class="n">new_damping</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particles</span> <span class="o">=</span> <span class="n">new_particles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">param_particle</span><span class="p">(</span><span class="n">particles</span><span class="p">)</span> <span class="k">if</span> <span class="n">include_rad</span>
                <span class="k">else</span> <span class="n">state</span><span class="o">.</span><span class="n">param_particle_pos</span><span class="p">(</span><span class="n">particles</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dif_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_diftile</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_err_paramvals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new_damping</span><span class="o">=</span><span class="n">new_damping</span><span class="p">)</span></div>

<div class="viewcode-block" id="LMParticleGroupCollection"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMParticleGroupCollection">[docs]</a><span class="k">class</span> <span class="nc">LMParticleGroupCollection</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt on all particles in a state.</span>

<span class="sd">    Convenience wrapper for LMParticles. Generates a separate instance</span>
<span class="sd">    for the particle groups each time and optimizes with that, since</span>
<span class="sd">    storing J for the particles is too large.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        state : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to optimize</span>
<span class="sd">        region_size : Int or 3-element list-like of ints, optional</span>
<span class="sd">            The region size for sub-blocking particles. Default is 40</span>
<span class="sd">        do_calc_size : Bool, optional</span>
<span class="sd">            If True, calculates the region size internally based on</span>
<span class="sd">            the maximum allowed memory. Default is True</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum allowed memory for J to occupy. Default is 1e9</span>
<span class="sd">        get_cos : Bool, optional</span>
<span class="sd">            Set to True to include the model cosine in the statistics</span>
<span class="sd">            on each individual group&#39;s run, using `LMEngine`</span>
<span class="sd">            get_termination_stats(). Stored in self.stats. Default is</span>
<span class="sd">            False</span>
<span class="sd">        save_J : Bool</span>
<span class="sd">            Set to True to create a series of temp files that save J</span>
<span class="sd">            for each group of particles. Needed for do_internal_run().</span>
<span class="sd">            Default is False.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        Pass any kwargs that would be passed to LMParticles. Stored in</span>
<span class="sd">        self._kwargs for reference.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        stats : List</span>
<span class="sd">            A list of the termination stats for each sub-block of particles</span>
<span class="sd">        particle_groups : List</span>
<span class="sd">            A list of particle groups. Element [i] in the list is a</span>
<span class="sd">            numpy.ndarray of the indices in group [i].</span>
<span class="sd">        region_size : Int or 3-element list-like</span>
<span class="sd">            The region size of the tiles. If `do_calc_size` is True,</span>
<span class="sd">            region_size will be the calculated value, which may differ</span>
<span class="sd">            from the input value.</span>
<span class="sd">        _kwargs : Dict</span>
<span class="sd">            The ``**kwargs`` passed to LMParticles.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        reset()</span>
<span class="sd">            Re-calculate all the groups</span>
<span class="sd">        do_run_1()</span>
<span class="sd">            Run do_run_1 for every group of particles</span>
<span class="sd">        do_run_2()</span>
<span class="sd">            Run do_run_2 for every group of particles</span>
<span class="sd">        do_internal_run()</span>
<span class="sd">            Run do_internal_run for every group of particles</span>

<span class="sd">    See Also</span>
<span class="sd">    -------</span>
<span class="sd">        LMParticles : LM optimization designed for optimizing state particles.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Since storing J for many particles can require a huge amount of</span>
<span class="sd">    memory, this object proceeds by re-initializing a separate LMParticles</span>
<span class="sd">    instance for each group of particles, calculating and then discarding</span>
<span class="sd">    J each time. The calculated J&#39;s can be kept by setting `save_J` to</span>
<span class="sd">    True, which saves each J for each group in a separate tempfile,</span>
<span class="sd">    located in the current directory. The J&#39;s can then be loaded again to</span>
<span class="sd">    attempt a second step without re-calculating J. However, for a big</span>
<span class="sd">    image this can attempt to store _a_lot_ of temp files, which might be</span>
<span class="sd">    more than the operating system limit (as temp files are always open),</span>
<span class="sd">    which will raise an error. So use with caution. Deleting any</span>
<span class="sd">    references to the temp files by deleting the LMParticleGroupCollection</span>
<span class="sd">    instance will close and remove the temporary files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">do_calc_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span>
            <span class="n">get_cos</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">save_J</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">region_size</span> <span class="o">=</span> <span class="n">region_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_cos</span> <span class="o">=</span> <span class="n">get_cos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_J</span> <span class="o">=</span> <span class="n">save_J</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="n">max_mem</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">do_calc_size</span><span class="o">=</span><span class="n">do_calc_size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_region_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">do_calc_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">new_damping</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">new_max_mem</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the particle groups and optionally the region size and damping.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            new_region_size : : Int or 3-element list-like of ints, optional</span>
<span class="sd">                The region size for sub-blocking particles. Default is 40</span>
<span class="sd">            do_calc_size : Bool, optional</span>
<span class="sd">                If True, calculates the region size internally based on</span>
<span class="sd">                the maximum allowed memory. Default is True</span>
<span class="sd">            new_damping : Float or None, optional</span>
<span class="sd">                The new damping of the optimizer. Set to None to leave</span>
<span class="sd">                as the default for LMParticles. Default is None.</span>
<span class="sd">            new_max_mem : Numeric, optional</span>
<span class="sd">                The maximum allowed memory for J to occupy. Default is 1e9</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">new_region_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region_size</span> <span class="o">=</span> <span class="n">new_region_size</span>
        <span class="k">if</span> <span class="n">new_max_mem</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="n">new_max_mem</span>
        <span class="k">if</span> <span class="n">do_calc_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">region_size</span> <span class="o">=</span> <span class="n">calc_particle_group_region_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span>
                    <span class="n">region_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">region_size</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_groups</span> <span class="o">=</span> <span class="n">separate_particles_into_groups</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">region_size</span><span class="p">,</span> <span class="n">doshift</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_damping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;damping&#39;</span><span class="p">:</span><span class="n">new_damping</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_J</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_groups</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">CLOG</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Attempting to create many open files. Consider increasing max_mem and/or region_size to avoid crashes.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tempfiles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_saved_J</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_groups</span><span class="p">)):</span>
                <span class="c1">#TemporaryFile is automatically deleted</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">,</span><span class="s1">&#39;tile&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_tempfiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryFile</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_saved_J</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_tmpfiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_index</span><span class="p">):</span>
        <span class="n">j_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempfiles</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">group_index</span><span class="p">]</span>
        <span class="n">tile_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tempfiles</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">group_index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#And we rewind before we return:</span>
        <span class="n">j_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tile_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">j_file</span><span class="p">,</span> <span class="n">tile_file</span>

    <span class="k">def</span> <span class="nf">_dump_j_diftile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_index</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">tile</span><span class="p">):</span>
        <span class="n">j_file</span><span class="p">,</span> <span class="n">tile_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tmpfiles</span><span class="p">(</span><span class="n">group_index</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">j_file</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">tile_file</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_load_j_diftile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_index</span><span class="p">):</span>
        <span class="n">j_file</span><span class="p">,</span> <span class="n">tile_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tmpfiles</span><span class="p">(</span><span class="n">group_index</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">j_file</span><span class="p">)</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">tile_file</span><span class="p">)</span>
        <span class="n">JTJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">J</span><span class="p">,</span> <span class="n">JTJ</span><span class="p">,</span> <span class="n">tile</span>

    <span class="k">def</span> <span class="nf">_do_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;workhorse for the self.do_run_xx methods.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_groups</span><span class="p">)):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">particle_groups</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="n">lp</span> <span class="o">=</span> <span class="n">LMParticles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">lp</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">JTJ</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">_dif_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_j_diftile</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                <span class="n">lp</span><span class="o">.</span><span class="n">do_run_1</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span>
                <span class="n">lp</span><span class="o">.</span><span class="n">do_run_2</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;internal&#39;</span><span class="p">:</span>
                <span class="n">lp</span><span class="o">.</span><span class="n">do_internal_run</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lp</span><span class="o">.</span><span class="n">get_termination_stats</span><span class="p">(</span><span class="n">get_cos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cos</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_J</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;internal&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_dump_j_diftile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">lp</span><span class="o">.</span><span class="n">_dif_tile</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_saved_J</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">do_run_1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls LMParticles.do_run_1 for each group of particles.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_run</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_run_2</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls LMParticles.do_run_2 for each group of particles.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_run</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;2&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_internal_run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls LMParticles.do_internal_run for each group of particles.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_J</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;self.save_J=True required for do_internal_run()&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_saved_J</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;J, JTJ have not been pre-computed. Call do_run_1 or do_run_2&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_run</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;internal&#39;</span><span class="p">)</span></div>

<span class="k">class</span> <span class="nc">AugmentedState</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Augments a state with a set of radii(z) parameters.</span>

<span class="sd">    Operates by updating the radii as ``R`` -&gt; ``R0*np.exp(legval(zp))``,</span>
<span class="sd">    where ``zp`` is a rescaled ``z`` coordinate and ``R0`` the initial</span>
<span class="sd">    radii. The order of the Legendre polynomial for the rescaling is set</span>
<span class="sd">    by ``rz_order``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        state : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to augment.</span>
<span class="sd">        param_names : list</span>
<span class="sd">            The list of the parameter names to include in the augmented</span>
<span class="sd">            state. Can contain any parameters except the particle radii</span>
<span class="sd">        rz_order : Int, optional</span>
<span class="sd">            The order of the Legendre polynomial used for rescaling.</span>
<span class="sd">            Default is 3.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        reset()</span>
<span class="sd">            Resets the augmented state by resetting the initial positions</span>
<span class="sd">            and radii used for updating the particles. Use if any pos or</span>
<span class="sd">            rad has been updated outside of the augmented state.</span>
<span class="sd">        update(param_vals)</span>
<span class="sd">            Updates the augmented state</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMAugmentedState : Levenberg-Marquadt optimization with an</span>
<span class="sd">            ``AugmentedState``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">        This could be extended to do xyzshift(xyz), radii(xyz)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">rz_order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">rad_nms</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">param_radii</span><span class="p">()</span>
        <span class="n">has_rad</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">rad_nms</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">has_rad</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;param_names must not contain any radii.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span> <span class="o">=</span> <span class="n">param_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_st_params</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rz_order</span> <span class="o">=</span> <span class="n">rz_order</span>

        <span class="c1">#Controling which params are globals, which are r(xyz) parameters</span>
        <span class="n">globals_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_st_params</span> <span class="o">+</span> <span class="n">rz_order</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
        <span class="n">globals_mask</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_st_params</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">rscale_mask</span> <span class="o">=</span> <span class="o">-</span><span class="n">globals_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">globals_mask</span> <span class="o">=</span> <span class="n">globals_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rscale_mask</span> <span class="o">=</span> <span class="n">rscale_mask</span>

        <span class="n">param_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">globals_mask</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;float&#39;</span><span class="p">)</span>
        <span class="n">param_vals</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_st_params</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">param_names</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="n">param_vals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resets the initial radii used for updating the particles. Call</span>
<span class="sd">        if any of the particle radii or positions have been changed</span>
<span class="sd">        external to the augmented state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">obj_get_positions</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rad_nms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">param_particle_rad</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pos_nms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">param_particle_pos</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_rad_nms</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initial_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_pos_nms</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">rad_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Right now exp(self._poly(z))&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_poly</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span>

    <span class="k">def</span> <span class="nf">_poly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Right now legval(z)&quot;&quot;&quot;</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">oshape</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">zmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">shp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">zmin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">zmid</span> <span class="o">=</span> <span class="n">zmax</span> <span class="o">*</span> <span class="mf">0.5</span>

        <span class="n">coeffs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale_mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">coeffs</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="o">*</span><span class="n">z</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">legval</span><span class="p">((</span><span class="n">z</span><span class="o">-</span><span class="n">zmid</span><span class="p">)</span><span class="o">/</span><span class="n">zmid</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale_mask</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">ans</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates all the parameters of the state + rscale(z)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_rscl_x_params</span><span class="p">(</span><span class="n">param_vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale_mask</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">,</span> <span class="n">param_vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">globals_mask</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">FloatingPointError</span><span class="p">(</span><span class="s1">&#39;state update caused nans in residuals&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_rscl_x_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_rscl_params</span><span class="p">):</span>
        <span class="c1">#1. What to change:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_pos</span>

        <span class="c1">#2. New, old values:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rscale_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_rscl_params</span>
        <span class="n">new_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rad_func</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">rnew</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initial_rad</span> <span class="o">*</span> <span class="n">new_scale</span>
        <span class="c1">#FIXME you can do a full update without the extra convolution</span>
        <span class="c1">#... right now don&#39;t worry about it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_rad_nms</span><span class="p">,</span> <span class="n">rnew</span><span class="p">)</span>

<div class="viewcode-block" id="LMAugmentedState"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.LMAugmentedState">[docs]</a><span class="k">class</span> <span class="nc">LMAugmentedState</span><span class="p">(</span><span class="n">LMGlobals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt on an augmented state.</span>

<span class="sd">    Contains all the options from the M. Transtrum J. Sethna 2012 ArXiV</span>
<span class="sd">    paper. See LMEngine for further documentation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        aug_state : :class:``peri.optimize.opt.AugmentedState``</span>
<span class="sd">            The state to optimize. Stored as self.aug_state</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum memory to use for the optimization; controls pixel</span>
<span class="sd">            decimation. Default is 1e9. Stored as self.max_mem.</span>
<span class="sd">        opt_kwargs : Dict, optional</span>
<span class="sd">            Dict of ``**kwargs`` for opt implementation. Right now only for</span>
<span class="sd">            get_num_px_jtj, i.e. keys of &#39;decimate&#39;, min_redundant&#39;.</span>
<span class="sd">            Default is `{}`. Stored as self.opt_kwargs.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        num_pix : Int</span>
<span class="sd">            The number of pixels of the residuals used to calculate J.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">        reset(new_damping=None)</span>
<span class="sd">            Resets the augmented state, counters, etc to zero, allowing</span>
<span class="sd">            more runs to commence.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        LMEngine : Parent class for all Levenberg-Marquardt (LM) optimization</span>
<span class="sd">        LMGlobals : LM optimization on globals without an ``AugmentedState``</span>
<span class="sd">        AugmentedState : The class used by ``LMAugmentedState``.</span>
<span class="sd">        LMParticles : LM optimization designed for optimizing state particles.</span>
<span class="sd">        LMParticleGroupCollection : LM optimization on all particles in a</span>
<span class="sd">            state.</span>
<span class="sd">        LMAugmentedState : LMGlobals with additional R(z) parameters.</span>
<span class="sd">        do_levmarq : Convenience function for LMGlobals</span>
<span class="sd">        do_levmarq_particles : Convenience function for optimizing particles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aug_state</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">opt_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span> <span class="o">=</span> <span class="n">aug_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">aug_state</span><span class="o">.</span><span class="n">state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_kwargs</span> <span class="o">=</span> <span class="n">opt_kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_mem</span> <span class="o">=</span> <span class="n">max_mem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_pix</span> <span class="o">=</span> <span class="n">get_num_px_jtj</span><span class="p">(</span><span class="n">aug_state</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">aug_state</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_kwargs</span><span class="p">)</span>
        <span class="c1"># super(LMAugmentedState, self).__init__(**kwargs)</span>
        <span class="n">LMEngine</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_err_paramvals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_error</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fractol</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">calc_J</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1">#0. Setup</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">state</span>
        <span class="n">sa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">sa</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_pix</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span> <span class="o">*=</span> <span class="mi">0</span>
        <span class="c1"># the _direction_ of the exact gradient of the model, rescaled later</span>
        <span class="n">graderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">sa</span><span class="o">.</span><span class="n">param_vals</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>

        <span class="c1">#1. J for the state:</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span><span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">],</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">,</span> <span class="n">graderr</span><span class="p">]])}</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="n">param_names</span>
        <span class="n">_</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inds</span> <span class="o">=</span> <span class="n">get_rand_Japprox</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">num_inds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_pix</span><span class="p">,</span>
                <span class="n">include_cost</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>  <span class="c1"># storing via out kwarg</span>

        <span class="c1">#2. J for the augmented portion:</span>
        <span class="n">old_aug_vals</span> <span class="o">=</span> <span class="n">sa</span><span class="o">.</span><span class="n">param_vals</span><span class="p">[</span><span class="n">sa</span><span class="o">.</span><span class="n">rscale_mask</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">er0</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span>
        <span class="n">ind0</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">old_aug_vals</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">old_aug_vals</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">dx</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">dl</span>
            <span class="n">sa</span><span class="o">.</span><span class="n">update_rscl_x_params</span><span class="p">(</span><span class="n">old_aug_vals</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">i1</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="bp">self</span><span class="o">.</span><span class="n">_inds</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1">#J = grad(residuals)</span>
            <span class="n">der</span> <span class="o">=</span> <span class="p">(</span><span class="n">i1</span><span class="o">-</span><span class="n">i0</span><span class="p">)</span><span class="o">/</span><span class="n">dl</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="p">[</span><span class="n">ind0</span><span class="o">+</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">der</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">graderr</span><span class="p">[</span><span class="n">ind0</span><span class="o">+</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">error</span> <span class="o">-</span> <span class="n">er0</span><span class="p">)</span><span class="o">/</span><span class="n">dl</span>
        <span class="c1">#resetting to prev. params:</span>
        <span class="n">sa</span><span class="o">.</span><span class="n">update_rscl_x_params</span><span class="p">(</span><span class="n">old_aug_vals</span><span class="p">)</span>

        <span class="c1"># Rescaling the grad of cost to the size we expect from the inds:</span>
        <span class="n">rescale</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_graderr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">graderr</span><span class="p">)</span> <span class="o">*</span> <span class="n">rescale</span>

    <span class="k">def</span> <span class="nf">update_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">error</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resets the aug_state and the LMEngine&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">aug_state</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LMAugmentedState</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not supported for LMAugmentedState&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_select_J</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Not yet implemented for LMAugmentedState&#39;</span><span class="p">)</span></div>

<span class="c1">#=============================================================================#</span>
<span class="c1">#         ~~~~~             Convenience Functions             ~~~~~</span>
<span class="c1">#=============================================================================#</span>
<div class="viewcode-block" id="do_levmarq"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.do_levmarq">[docs]</a><span class="k">def</span> <span class="nf">do_levmarq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
        <span class="n">run_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">collect_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rz_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">run_type</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Runs Levenberg-Marquardt optimization on a state.</span>

<span class="sd">    Convenience wrapper for LMGlobals. Same keyword args, but the defaults</span>
<span class="sd">    have been set to useful values for optimizing globals.</span>
<span class="sd">    See LMGlobals and LMEngine for documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        do_levmarq_particles : Levenberg-Marquardt optimization of a</span>
<span class="sd">            specified set of particles.</span>

<span class="sd">        do_levmarq_all_particle_groups : Levenberg-Marquardt optimization</span>
<span class="sd">            of all the particles in the state.</span>

<span class="sd">        LMGlobals : Optimizer object; the workhorse of do_levmarq.</span>

<span class="sd">        LMEngine : Engine superclass for all the optimizers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rz_order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="n">AugmentedState</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">rz_order</span><span class="o">=</span><span class="n">rz_order</span><span class="p">)</span>
        <span class="n">lm</span> <span class="o">=</span> <span class="n">LMAugmentedState</span><span class="p">(</span><span class="n">aug</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="n">run_length</span><span class="p">,</span>
                <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="n">decrease_damp_factor</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span>
                <span class="n">eig_update</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lm</span> <span class="o">=</span> <span class="n">LMGlobals</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="n">run_length</span><span class="p">,</span>
                <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="n">decrease_damp_factor</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span>
                <span class="n">eig_update</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">run_type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">lm</span><span class="o">.</span><span class="n">do_run_2</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">run_type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">lm</span><span class="o">.</span><span class="n">do_run_1</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;run_type=1,2 only&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">collect_stats</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lm</span><span class="o">.</span><span class="n">get_termination_stats</span><span class="p">()</span></div>

<div class="viewcode-block" id="do_levmarq_particles"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.do_levmarq_particles">[docs]</a><span class="k">def</span> <span class="nf">do_levmarq_particles</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">particles</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span>
        <span class="n">run_length</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">collect_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt optimization on a set of particles.</span>

<span class="sd">    Convenience wrapper for LMParticles. Same keyword args, but the</span>
<span class="sd">    defaults have been set to useful values for optimizing particles.</span>
<span class="sd">    See LMParticles and LMEngine for documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        do_levmarq_all_particle_groups : Levenberg-Marquardt optimization</span>
<span class="sd">            of all the particles in the state.</span>

<span class="sd">        do_levmarq : Levenberg-Marquardt optimization of the entire state;</span>
<span class="sd">            useful for optimizing global parameters.</span>

<span class="sd">        LMParticles : Optimizer object; the workhorse of do_levmarq_particles.</span>

<span class="sd">        LMEngine : Engine superclass for all the optimizers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">LMParticles</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">particles</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="n">run_length</span><span class="p">,</span>
            <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="n">decrease_damp_factor</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">lp</span><span class="o">.</span><span class="n">do_run_2</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">collect_stats</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lp</span><span class="o">.</span><span class="n">get_termination_stats</span><span class="p">()</span></div>

<div class="viewcode-block" id="do_levmarq_all_particle_groups"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.do_levmarq_all_particle_groups">[docs]</a><span class="k">def</span> <span class="nf">do_levmarq_all_particle_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">collect_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Levenberg-Marquardt optimization for every particle in the state.</span>

<span class="sd">    Convenience wrapper for LMParticleGroupCollection. Same keyword args,</span>
<span class="sd">    but I&#39;ve set the defaults to what I&#39;ve found to be useful values for</span>
<span class="sd">    optimizing particles. See LMParticleGroupCollection for documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">        do_levmarq_particles : Levenberg-Marquardt optimization of a</span>
<span class="sd">            specified set of particles.</span>

<span class="sd">        do_levmarq : Levenberg-Marquardt optimization of the entire state;</span>
<span class="sd">            useful for optimizing global parameters.</span>

<span class="sd">        LMParticleGroupCollection : The workhorse of do_levmarq.</span>

<span class="sd">        LMEngine : Engine superclass for all the optimizers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lp</span> <span class="o">=</span> <span class="n">LMParticleGroupCollection</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span><span class="n">region_size</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="n">damping</span><span class="p">,</span>
            <span class="n">run_length</span><span class="o">=</span><span class="n">run_length</span><span class="p">,</span> <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="n">decrease_damp_factor</span><span class="p">,</span>
            <span class="n">get_cos</span><span class="o">=</span><span class="n">collect_stats</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">lp</span><span class="o">.</span><span class="n">do_run_2</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">collect_stats</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lp</span><span class="o">.</span><span class="n">stats</span></div>

<span class="k">def</span> <span class="nf">do_levmarq_n_directions</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">damping</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">collect_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">marquardt_damping</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimization of a state along a specific set of directions in parameter</span>
<span class="sd">    space.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        s : :class:`peri.states.State`</span>
<span class="sd">            The state to optimize</span>
<span class="sd">        directions : np.ndarray</span>
<span class="sd">            [n,d] element numpy.ndarray of the n directions in the d-</span>
<span class="sd">            dimensional space to optimize along. `directions` is trans-</span>
<span class="sd">            formed to a unit vector internally</span>
<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        Any parameters passed to LMEngine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># normal = direction / np.sqrt(np.dot(direction, direction))</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">normals</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`directions` must not be 0s or contain nan&#39;</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">OptState</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>
    <span class="n">lo</span> <span class="o">=</span> <span class="n">LMOptObj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="n">run_length</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span>
            <span class="n">damping</span><span class="p">,</span> <span class="n">marquardt_damping</span><span class="o">=</span><span class="n">marquardt_damping</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">lo</span><span class="o">.</span><span class="n">do_run_1</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">collect_stats</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lo</span><span class="o">.</span><span class="n">get_termination_stats</span><span class="p">()</span>

<div class="viewcode-block" id="burn"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.burn">[docs]</a><span class="k">def</span> <span class="nf">burn</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">n_loop</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">collect_stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">rz_order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fractol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
        <span class="n">errtol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;burn&#39;</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">include_rad</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">do_line_min</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">partial_log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dowarn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Optimizes all the parameters of a state.</span>

<span class="sd">    Burns a state through calling LMParticleGroupCollection and LMGlobals/</span>
<span class="sd">    LMAugmentedState.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        s : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to optimize</span>
<span class="sd">        n_loop : Int, optional</span>
<span class="sd">            The number of times to loop over in the optimizer. Default is 6.</span>
<span class="sd">        collect_stats : Bool, optional</span>
<span class="sd">            Whether or not to collect information on the optimizer&#39;s</span>
<span class="sd">            performance. Default is False.</span>
<span class="sd">        desc : string, optional</span>
<span class="sd">            Description to append to the states.save() call every loop.</span>
<span class="sd">            Set to None to avoid saving. Default is &#39;&#39;, which selects</span>
<span class="sd">            one of &#39;burning&#39;, &#39;polishing&#39;, &#39;doing_positions&#39;</span>
<span class="sd">        rz_order: Int, optional</span>
<span class="sd">            Set to an int &gt; 0 to optimize with an augmented state (R(z) as</span>
<span class="sd">            a global parameter) vs. with the normal global parameters;</span>
<span class="sd">            rz_order is the order of the polynomial approximate for R(z).</span>
<span class="sd">            Default is 0 (no augmented state).</span>
<span class="sd">        fractol : Float, optional</span>
<span class="sd">            Fractional change in error at which to terminate. Default 1e-4</span>
<span class="sd">        errtol : Float, optional</span>
<span class="sd">            Absolute change in error at which to terminate. Default 1e-2</span>
<span class="sd">        mode : {&#39;burn&#39;, &#39;do-particles&#39;, or &#39;polish&#39;}, optional</span>
<span class="sd">            What mode to optimize with.</span>
<span class="sd">            * &#39;burn&#39;          : Your state is far from the minimum.</span>
<span class="sd">            * &#39;do-particles&#39;  : Positions far from minimum, globals well-fit.</span>
<span class="sd">            * &#39;polish&#39;        : The state is close to the minimum.</span>
<span class="sd">            &#39;burn&#39; is the default. Only `polish` will get to the global</span>
<span class="sd">            minimum.</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum amount of memory allowed for the optimizers&#39; J&#39;s,</span>
<span class="sd">            for both particles &amp; globals. Default is 1e9, i.e. 1GB per</span>
<span class="sd">            optimizer.</span>
<span class="sd">        do_line_min : Bool or &#39;default&#39;, optional</span>
<span class="sd">            Set to True to do an additional, third optimization per loop</span>
<span class="sd">            which optimizes along the subspace spanned by the last 3 steps</span>
<span class="sd">            of the burn()&#39;s trajectory. In principle this should signifi-</span>
<span class="sd">            cantly speed up the convergence; in practice it sometimes does,</span>
<span class="sd">            sometimes doesn&#39;t. Default is &#39;default&#39;, which picks by mode:</span>
<span class="sd">            * &#39;burn&#39;          : False</span>
<span class="sd">            * &#39;do-particles&#39;  : False</span>
<span class="sd">            * &#39;polish&#39;        : True</span>
<span class="sd">        dowarn : Bool, optional</span>
<span class="sd">            Whether to log a warning if termination results from finishing</span>
<span class="sd">            loops rather than from convergence. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        dictionary</span>
<span class="sd">            Dictionary of convergence information. Contains whether the</span>
<span class="sd">            optimization has converged (key ``&#39;converged&#39;``), the values of the</span>
<span class="sd">            state after each loop (key ``&#39;all_loop_values&#39;``).</span>
<span class="sd">            The values of the state&#39;s parameters after each part of the</span>
<span class="sd">            loop: globals, particles, linemin. If ``collect_stats`` is set,</span>
<span class="sd">            then also contains lists of termination dicts from globals,</span>
<span class="sd">            particles, and line minimization (keys ``&#39;global_stats&#39;``,</span>
<span class="sd">            ``&#39;particle_stats&#39;``, and ``&#39;line_stats``&#39;).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Proceeds by alternating between one Levenberg-Marquardt step</span>
<span class="sd">    optimizing the globals, one optimizing the particles, and repeating</span>
<span class="sd">    until termination.</span>

<span class="sd">    In addition, if `do_line_min` is True, at the end of each loop</span>
<span class="sd">    step an additional optimization is tried along the subspaced spanned</span>
<span class="sd">    by the steps taken during the last 3 loops. Ideally, this changes the</span>
<span class="sd">    convergence from linear to quadratic, but it doesn&#39;t always do much.</span>

<span class="sd">    Each of the 3 options proceed by optimizing as follows:</span>
<span class="sd">    * burn            : lm.do_run_2(), lp.do_run_2(). No psf, 2 loops on lm.</span>
<span class="sd">    * do-particles    : lp.do_run_2(), scales for ilm, bkg&#39;s</span>
<span class="sd">    * polish          : lm.do_run_2(), lp.do_run_2(). Everything, 1 loop each.</span>
<span class="sd">    where lm is a globals LMGlobals instance, and lp a</span>
<span class="sd">    LMParticleGroupCollection instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># It would be nice if some of these magic #&#39;s (region size,</span>
    <span class="c1"># num_eig_dirs, etc) were calculated in a good way. FIXME</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;burn&#39;</span><span class="p">,</span> <span class="s1">&#39;do-particles&#39;</span><span class="p">,</span> <span class="s1">&#39;polish&#39;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mode must be one of burn, do-particles, polish&#39;</span><span class="p">)</span>

    <span class="c1">#1. Setting Defaults</span>
    <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="n">desc</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">+</span> <span class="s1">&#39;ing&#39;</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;do-particles&#39;</span> <span class="k">else</span> <span class="s1">&#39;doing-particles&#39;</span>

    <span class="n">eig_update</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;do-particles&#39;</span><span class="p">)</span>
    <span class="n">glbl_run_length</span> <span class="o">=</span> <span class="mi">3</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;do-particles&#39;</span> <span class="k">else</span> <span class="mi">6</span>
    <span class="n">glbl_mx_itr</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;burn&#39;</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">use_accel</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;burn&#39;</span><span class="p">)</span>
    <span class="n">rz_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rz_order</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">do_line_min</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">do_line_min</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;polish&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;do-particles&#39;</span><span class="p">:</span>
        <span class="n">glbl_nms</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ilm-scale&#39;</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">]</span>  <span class="c1">#bkg?</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">remove_params</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;polish&#39;</span> <span class="k">else</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;psf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">params</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;zscale&#39;</span><span class="p">])</span>  <span class="c1"># FIXME explicit params</span>
        <span class="n">glbl_nms</span> <span class="o">=</span> <span class="n">name_globals</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">remove_params</span><span class="o">=</span><span class="n">remove_params</span><span class="p">)</span>

    <span class="n">all_lp_stats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_lm_stats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_line_stats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_loop_values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">_delta_vals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># storing the directions we&#39;ve moved along for line min</span>
    <span class="c1">#2. Optimize</span>
    <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Start of loop </span><span class="si">%d</span><span class="s1">:</span><span class="se">\t</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_loop</span><span class="p">):</span>
        <span class="n">start_err</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span>
        <span class="n">start_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">params</span><span class="p">])</span>
        <span class="c1">#2a. Globals</span>
        <span class="c1"># glbl_dmp = 0.3 if a == 0 else 3e-2</span>
        <span class="c1">####FIXME we damp degenerate but convenient spaces in the ilm, bkg</span>
        <span class="c1">####manually, but we should do it more betterer.</span>
        <span class="n">BAD_DAMP</span> <span class="o">=</span> <span class="mf">1e7</span>
        <span class="n">BAD_LIST</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;ilm-scale&#39;</span><span class="p">,</span> <span class="n">BAD_DAMP</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;ilm-off&#39;</span><span class="p">,</span> <span class="n">BAD_DAMP</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;ilm-z-0&#39;</span><span class="p">,</span>
                <span class="n">BAD_DAMP</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;bkg-z-0&#39;</span><span class="p">,</span> <span class="n">BAD_DAMP</span><span class="p">]]</span>
        <span class="c1">####</span>
        <span class="n">glbl_dmp</span> <span class="o">=</span> <span class="n">vectorize_damping</span><span class="p">(</span><span class="n">glbl_nms</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;rz&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">rz_order</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                <span class="n">increase_list</span><span class="o">=</span><span class="p">[[</span><span class="s1">&#39;psf-&#39;</span><span class="p">,</span> <span class="mf">3e1</span><span class="p">]]</span> <span class="o">+</span> <span class="n">BAD_LIST</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">!=</span> <span class="s1">&#39;do-particles&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">partial_log</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">)</span>
            <span class="n">gstats</span> <span class="o">=</span> <span class="n">do_levmarq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">glbl_nms</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="n">glbl_mx_itr</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span>
                    <span class="n">glbl_run_length</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span><span class="n">eig_update</span><span class="p">,</span> <span class="n">num_eig_dirs</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                    <span class="n">eig_update_frequency</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rz_order</span><span class="o">=</span><span class="n">rz_order</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span>
                    <span class="n">glbl_dmp</span><span class="p">,</span> <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="mf">10.</span><span class="p">,</span> <span class="n">use_accel</span><span class="o">=</span><span class="n">use_accel</span><span class="p">,</span>
                    <span class="n">collect_stats</span><span class="o">=</span><span class="n">collect_stats</span><span class="p">,</span> <span class="n">fractol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">fractol</span><span class="p">,</span>
                    <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">partial_log</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">set_level</span><span class="p">(</span><span class="s1">&#39;info&#39;</span><span class="p">)</span>
            <span class="n">all_lm_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gstats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">states</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Globals,   loop </span><span class="si">{}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
        <span class="n">all_loop_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1">#2b. Particles</span>
        <span class="n">prtl_dmp</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="mf">1e-2</span>
        <span class="c1">#For now, I&#39;m calculating the region size. This might be a bad idea</span>
        <span class="c1">#because 1 bad particle can spoil the whole group.</span>
        <span class="n">pstats</span> <span class="o">=</span> <span class="n">do_levmarq_all_particle_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">region_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">do_calc_size</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">run_length</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">damping</span><span class="o">=</span><span class="n">prtl_dmp</span><span class="p">,</span> <span class="n">fractol</span><span class="o">=</span><span class="mf">0.1</span><span class="o">*</span><span class="n">fractol</span><span class="p">,</span> <span class="n">collect_stats</span><span class="o">=</span>
                <span class="n">collect_stats</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">,</span> <span class="n">include_rad</span><span class="o">=</span><span class="n">include_rad</span><span class="p">)</span>
        <span class="n">all_lp_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pstats</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">states</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Particles, loop </span><span class="si">{}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="n">all_loop_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1">#2c. Line min?</span>
        <span class="n">end_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">params</span><span class="p">])</span>
        <span class="n">_delta_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start_params</span> <span class="o">-</span> <span class="n">end_params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">do_line_min</span><span class="p">:</span>
            <span class="n">all_line_stats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">do_levmarq_n_directions</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">_delta_vals</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:],</span>
                    <span class="n">collect_stats</span><span class="o">=</span><span class="n">collect_stats</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">states</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
            <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Line min., loop </span><span class="si">{}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
            <span class="n">all_loop_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

        <span class="c1">#2d. terminate?</span>
        <span class="n">new_err</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span>
        <span class="n">derr</span> <span class="o">=</span> <span class="n">start_err</span> <span class="o">-</span> <span class="n">new_err</span>
        <span class="n">dobreak</span> <span class="o">=</span> <span class="p">(</span><span class="n">derr</span><span class="o">/</span><span class="n">new_err</span> <span class="o">&lt;</span> <span class="n">fractol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">derr</span> <span class="o">&lt;</span> <span class="n">errtol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dobreak</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">dowarn</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dobreak</span><span class="p">):</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;burn() did not converge; consider re-running&#39;</span><span class="p">)</span>

    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;converged&#39;</span><span class="p">:</span><span class="n">dobreak</span><span class="p">,</span> <span class="s1">&#39;all_loop_values&#39;</span><span class="p">:</span><span class="n">all_loop_values</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">collect_stats</span><span class="p">:</span>
        <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;global_stats&#39;</span><span class="p">:</span><span class="n">all_lm_stats</span><span class="p">,</span> <span class="s1">&#39;particle_stats&#39;</span><span class="p">:</span><span class="n">all_lp_stats</span><span class="p">,</span>
                <span class="s1">&#39;line_stats&#39;</span><span class="p">:</span><span class="n">all_line_stats</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="finish"><a class="viewcode-back" href="../../../reference/opt.html#peri.opt.optimize.finish">[docs]</a><span class="k">def</span> <span class="nf">finish</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;finish&#39;</span><span class="p">,</span> <span class="n">n_loop</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="mf">1e9</span><span class="p">,</span> <span class="n">separate_psf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">fractol</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span> <span class="n">errtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">dowarn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crawls slowly to the minimum-cost state.</span>

<span class="sd">    Blocks the global parameters into small enough sections such that each</span>
<span class="sd">    can be optimized separately while including all the pixels (i.e. no</span>
<span class="sd">    decimation). Optimizes the globals, then the psf separately if desired,</span>
<span class="sd">    then particles, then a line minimization along the step direction to</span>
<span class="sd">    speed up convergence.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        s : :class:`peri.states.ImageState`</span>
<span class="sd">            The state to optimize</span>
<span class="sd">        desc : string, optional</span>
<span class="sd">            Description to append to the states.save() call every loop.</span>
<span class="sd">            Set to `None` to avoid saving. Default is `&#39;finish&#39;`.</span>
<span class="sd">        n_loop : Int, optional</span>
<span class="sd">            The number of times to loop over in the optimizer. Default is 4.</span>
<span class="sd">        max_mem : Numeric, optional</span>
<span class="sd">            The maximum amount of memory allowed for the optimizers&#39; J&#39;s,</span>
<span class="sd">            for both particles &amp; globals. Default is 1e9.</span>
<span class="sd">        separate_psf : Bool, optional</span>
<span class="sd">            If True, does the psf optimization separately from the rest of</span>
<span class="sd">            the globals, since the psf has a more tortuous fit landscape.</span>
<span class="sd">            Default is True.</span>
<span class="sd">        fractol : Float, optional</span>
<span class="sd">            Fractional change in error at which to terminate. Default 1e-4</span>
<span class="sd">        errtol : Float, optional</span>
<span class="sd">            Absolute change in error at which to terminate. Default 1e-2</span>
<span class="sd">        dowarn : Bool, optional</span>
<span class="sd">            Whether to log a warning if termination results from finishing</span>
<span class="sd">            loops rather than from convergence. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        dictionary</span>
<span class="sd">            Information about the optimization. Has two keys: ``&#39;converged&#39;``,</span>
<span class="sd">            a Bool which of whether optimization stopped due to convergence</span>
<span class="sd">            (True) or due to max number of iterations (False), and</span>
<span class="sd">            ``&#39;loop_values&#39;``, a [n_loop+1, N] ``numpy.ndarray`` of the</span>
<span class="sd">            state&#39;s values, at the start of optimization and at the end of</span>
<span class="sd">            each loop, before the line minimization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">params</span><span class="p">])]</span>
    <span class="n">remove_params</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;psf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">params</span> <span class="k">if</span> <span class="n">separate_psf</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># FIXME explicit params</span>
    <span class="nb">globals</span> <span class="o">=</span> <span class="n">name_globals</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">remove_params</span><span class="o">=</span><span class="n">remove_params</span><span class="p">)</span>
    <span class="c1">#FIXME this could be done much better, since much of the globals such</span>
    <span class="c1">#as the ilm are local. Could be done with sparse matrices and/or taking</span>
    <span class="c1">#nearby globals in a group and using the update tile only as the slicer,</span>
    <span class="c1">#rather than the full residuals.</span>
    <span class="n">gs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">max_mem</span> <span class="o">/</span> <span class="n">s</span><span class="o">.</span><span class="n">residuals</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
    <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">globals</span><span class="p">[</span><span class="n">a</span><span class="p">:</span><span class="n">a</span><span class="o">+</span><span class="n">gs</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">globals</span><span class="p">),</span> <span class="n">gs</span><span class="p">)]</span>
    <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Start  ``finish``:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_loop</span><span class="p">):</span>
        <span class="n">start_err</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span>
        <span class="c1">#1. Min globals:</span>
        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
            <span class="n">do_levmarq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">decrease_damp_factor</span><span class="o">=</span><span class="mf">20.</span><span class="p">,</span>
                    <span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">,</span> <span class="n">eig_update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">separate_psf</span><span class="p">:</span>
            <span class="n">do_levmarq</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">remove_params</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                    <span class="n">eig_update</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Globals,   loop </span><span class="si">{}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">states</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
        <span class="c1">#2. Min particles</span>
        <span class="n">do_levmarq_all_particle_groups</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mem</span><span class="o">=</span><span class="n">max_mem</span><span class="p">)</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Particles, loop </span><span class="si">{}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">states</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
        <span class="c1">#3. Append vals, line min:</span>
        <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">params</span><span class="p">]))</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
        <span class="n">do_levmarq_n_directions</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dv</span><span class="p">,</span> <span class="n">damping</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">errtol</span><span class="o">=</span><span class="mf">3e-4</span><span class="p">)</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Line min., loop </span><span class="si">{}</span><span class="s1">:</span><span class="se">\t</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">desc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">states</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="n">desc</span><span class="p">)</span>
        <span class="c1">#4. terminate?</span>
        <span class="n">new_err</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">error</span>
        <span class="n">derr</span> <span class="o">=</span> <span class="n">start_err</span> <span class="o">-</span> <span class="n">new_err</span>
        <span class="n">dobreak</span> <span class="o">=</span> <span class="p">(</span><span class="n">derr</span><span class="o">/</span><span class="n">new_err</span> <span class="o">&lt;</span> <span class="n">fractol</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">derr</span> <span class="o">&lt;</span> <span class="n">errtol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dobreak</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">dowarn</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dobreak</span><span class="p">):</span>
        <span class="n">CLOG</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;finish() did not converge; consider re-running&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;converged&#39;</span><span class="p">:</span><span class="n">dobreak</span><span class="p">,</span> <span class="s1">&#39;loop_values&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)}</span></div>

<span class="k">def</span> <span class="nf">fit_comp</span><span class="p">(</span><span class="n">new_comp</span><span class="p">,</span> <span class="n">old_comp</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fits a new component to an old component</span>

<span class="sd">    Calls do_levmarq to match the .get() fields of the two objects. The</span>
<span class="sd">    parameters of new_comp are modified in place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    new_comp : :class:`peri.comps.comp`</span>
<span class="sd">        The new object, whose parameters to update to fit the field of</span>
<span class="sd">        `old_comp`. Must have a .get() attribute which returns an ndarray</span>
<span class="sd">    old_comp : peri.comp</span>
<span class="sd">        The old ilm to match to.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">        Any keyword arguments to be passed to the optimizer LMGlobals</span>
<span class="sd">        through do_levmarq.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    do_levmarq : Levenberg-Marquardt minimization using a random subset</span>
<span class="sd">        of the image pixels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#resetting the category to ilm:</span>
    <span class="n">new_cat</span> <span class="o">=</span> <span class="n">new_comp</span><span class="o">.</span><span class="n">category</span>
    <span class="n">new_comp</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="s1">&#39;ilm&#39;</span>
    <span class="n">fake_s</span> <span class="o">=</span> <span class="n">states</span><span class="o">.</span><span class="n">ImageState</span><span class="p">(</span><span class="n">Image</span><span class="p">(</span><span class="n">old_comp</span><span class="o">.</span><span class="n">get</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()),</span> <span class="p">[</span><span class="n">new_comp</span><span class="p">],</span> <span class="n">pad</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">mdl</span><span class="o">=</span><span class="n">mdl</span><span class="o">.</span><span class="n">SmoothFieldModel</span><span class="p">())</span>
    <span class="n">do_levmarq</span><span class="p">(</span><span class="n">fake_s</span><span class="p">,</span> <span class="n">new_comp</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="n">new_comp</span><span class="o">.</span><span class="n">category</span> <span class="o">=</span> <span class="n">new_cat</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">PERI 0.1.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Matt Bierbaum, Brian Leahy.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>