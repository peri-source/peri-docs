<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Optimization and sampling &#8212; PERI 0.1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/mathconf.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="peri.comp" href="reference/comp.html" />
    <link rel="prev" title="Package architecture" href="architecture.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="reference/comp.html" title="peri.comp"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="architecture.html" title="Package architecture"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PERI 0.1.1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="optimization-and-sampling">
<h1>Optimization and sampling<a class="headerlink" href="#optimization-and-sampling" title="Permalink to this headline">¶</a></h1>
<p>As mentioned in the <a class="reference internal" href="walkthrough.html"><span class="doc">Walkthrough</span></a>, PERI works by fitting a
generative model to data. In the <a class="reference internal" href="walkthrough.html"><span class="doc">Walkthrough</span></a>, we obtained
an initial guess for the particle positions and radii from centroid methods. We
used this initial guess to create a state <code class="docutils literal"><span class="pre">st</span></code> with all the components of the
model. We now need to optimize the model.</p>
<p>First, the centroid methods do not provide a guess for global parameters such
as the illumination field or the point-spread function. Second, the centroid
methods frequently miss or mis-feature many particles. Third, we would like to
completely optimize the model to get maximally-accurate position and radii
measurements. In this section, we&#8217;ll discuss how to optimize a
<a class="reference internal" href="reference/states.html#peri.states.ImageState" title="peri.states.ImageState"><code class="xref py py-class docutils literal"><span class="pre">peri.states.ImageState</span></code></a> and accomplish all three of these goals.</p>
<p>Most of these steps are implemented in the <code class="xref py py-mod docutils literal"><span class="pre">peri.runner</span></code> convenience
functions.</p>
<div class="section" id="initial-optimization">
<h2>Initial Optimization<a class="headerlink" href="#initial-optimization" title="Permalink to this headline">¶</a></h2>
<p>The goal of the initial optimization is to fit the image accurately enough
to identify any missing particles. The initial guess for component values such
as the illumination and background fields are usually wildly off. Moreover,
centroid methods frequently return wildly inaccurate particle positions. Both
the global parameters such as the illumination and the local parameters such as
particle positions and radii need to be reasonable before we can find the
missing particles.</p>
<p><a class="reference internal" href="reference/opt.html#peri.opt.optimize.burn" title="peri.opt.optimize.burn"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.burn()</span></code></a> effectively runs this initial optimization. To do this
initial optimization, simply run:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">peri.opt.optimize</span> <span class="kn">as</span> <span class="nn">opt</span>
<span class="n">opt</span><span class="o">.</span><span class="n">burn</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;burn&#39;</span><span class="p">,</span> <span class="n">n_loop</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fractol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
<p>This will usually optimize a state sufficiently enough to add missing particles
to the image. If it does not, you can set <code class="docutils literal"><span class="pre">n_loop</span></code> to a larger value such as
6 or 10. Additionally, <code class="docutils literal"><span class="pre">opt.burn</span></code> saves a copy of the state every so often,
by calling <code class="docutils literal"><span class="pre">peri.states.save(st,</span> <span class="pre">desc='burning')</span></code>. If you do not want to
save the state every so oftern, set <code class="docutils literal"><span class="pre">desc=None</span></code> in <code class="docutils literal"><span class="pre">opt.burn</span></code>; if you want
to save with a different name then set <code class="docutils literal"><span class="pre">desc</span></code> to whatever you want; it will
be passed through to <a class="reference internal" href="reference/states.html#peri.states.save" title="peri.states.save"><code class="xref py py-func docutils literal"><span class="pre">peri.states.save()</span></code></a>.</p>
<p>Briefly, what does <a class="reference internal" href="reference/opt.html#peri.opt.optimize.burn" title="peri.opt.optimize.burn"><code class="xref py py-func docutils literal"><span class="pre">burn()</span></code></a> do? The state are optimized by
essentially curve-fitting with a <a class="reference external" href="https://en.wikipedia.org/wiki/Levenberg%E2%80%93Marquardt_algorithm">Levenberg-Marquardt algorithm</a>.
However, a typical state has too many parameters to optimize the entire state
at once. To deal with this, <code class="docutils literal"><span class="pre">opt.burn</span></code> optimizes the parameters in groups, first
optimizing the global parameters such as the illumination and background, then
optimizing the particle parameters. Since these two groups of parameters are
coupled, <code class="docutils literal"><span class="pre">opt.burn</span></code> then alternates back and forth between globals and
particles <code class="docutils literal"><span class="pre">n_loop</span></code> times or until a sufficient convergence is met &#8211; here
if the error changes by less than 10% of its best value (<code class="docutils literal"><span class="pre">fractol=0.1</span></code>) <a class="footnote-reference" href="#id3" id="id1">[1]</a>.
Finally, we&#8217;ve found empirically that it&#8217;s best to avoid optimizing some
parameters of the model (such as the point-spread function and the particle
zscale) until the end. Calling <a class="reference internal" href="reference/opt.html#peri.opt.optimize.burn" title="peri.opt.optimize.burn"><code class="xref py py-func docutils literal"><span class="pre">burn()</span></code></a> with
<code class="docutils literal"><span class="pre">mode='burn'</span></code> combines all these nuances into one convenience function <a class="footnote-reference" href="#id4" id="id2">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>If <code class="docutils literal"><span class="pre">burn</span></code> doesn&#8217;t converge sufficiently and instead stops because
it has iterated for <code class="docutils literal"><span class="pre">n_loop</span></code>, then it will log a warning. For this
initial optimization we&#8217;ll ignore it, since we&#8217;ll keep optimizing the
state later. However, if you get a warning like this in the later steps,
it might be worthwile to heed the warning and re-optimize the state.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>In addition, when the point-spread function or illumination are far
from their correct values, the particle radii tend to drift to bad
values before slowly coming back to the correct values. If you have a
pretty good initial guess for the radii, you can speed this up by
having <code class="docutils literal"><span class="pre">opt.burn</span></code> ignore the particle radii with the flag
<code class="docutils literal"><span class="pre">include_rad=False</span></code>.</td></tr>
</tbody>
</table>
<p>If you want more details on how <code class="docutils literal"><span class="pre">opt.burn</span></code> functions, see the documentation
or code. If your specific image or model is not optimized well by <code class="docutils literal"><span class="pre">opt.burn</span></code>,
or you want additional functionality, then you should look at these functions
which <code class="docutils literal"><span class="pre">opt.burn</span></code> calls or uses:</p>
<blockquote>
<div><dl class="docutils">
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.do_levmarq" title="peri.opt.optimize.do_levmarq"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.do_levmarq()</span></code></a></dt>
<dd>Levenberg-Marquardt (LM) optimization on whatever parameter groups
passed, additionall optimized for large parameter spaces.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.do_levmarq_all_particle_groups" title="peri.opt.optimize.do_levmarq_all_particle_groups"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.do_levmarq_all_particle_groups()</span></code></a></dt>
<dd>LM optimization on all the particles in the image.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.do_levmarq_particles" title="peri.opt.optimize.do_levmarq_particles"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.do_levmarq_particles()</span></code></a></dt>
<dd>LM optimization on a select number of particles.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMGlobals" title="peri.opt.optimize.LMGlobals"><code class="xref py py-class docutils literal"><span class="pre">peri.opt.optimize.LMGlobals</span></code></a></dt>
<dd>The class that <a class="reference internal" href="reference/opt.html#peri.opt.optimize.do_levmarq" title="peri.opt.optimize.do_levmarq"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.do_levmarq()</span></code></a> calls to do its
optimization. Has more options and attributes which are useful for
checking convergence.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMParticleGroupCollection" title="peri.opt.optimize.LMParticleGroupCollection"><code class="xref py py-class docutils literal"><span class="pre">peri.opt.optimize.LMParticleGroupCollection</span></code></a></dt>
<dd>The class that <a class="reference internal" href="reference/opt.html#peri.opt.optimize.do_levmarq_all_particle_groups" title="peri.opt.optimize.do_levmarq_all_particle_groups"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.do_levmarq_all_particle_groups()</span></code></a> calls
to do its optimization. Has more options and attributes which are
useful for checking convergence.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMParticles" title="peri.opt.optimize.LMParticles"><code class="xref py py-class docutils literal"><span class="pre">peri.opt.optimize.LMParticles</span></code></a></dt>
<dd>The class that both <a class="reference internal" href="reference/opt.html#peri.opt.optimize.do_levmarq_particles" title="peri.opt.optimize.do_levmarq_particles"><code class="xref py py-func docutils literal"><span class="pre">peri.opt.optimize.do_levmarq_particles()</span></code></a> and
<a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMParticleGroupCollection" title="peri.opt.optimize.LMParticleGroupCollection"><code class="xref py py-class docutils literal"><span class="pre">peri.opt.optimize.LMParticleGroupCollection</span></code></a> calls to do their
optimization. Has more options and attributes which are useful for
checking convergence.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMAugmentedState" title="peri.opt.optimize.LMAugmentedState"><code class="xref py py-class docutils literal"><span class="pre">peri.opt.optimize.LMAugmentedState</span></code></a></dt>
<dd>Like <a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMGlobals" title="peri.opt.optimize.LMGlobals"><code class="xref py py-class docutils literal"><span class="pre">LMGlobals</span></code></a> but also allows for effective parameters such as an
overall radii scale or a radii scale that changes with <code class="docutils literal"><span class="pre">z</span></code>.</dd>
<dt><a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMEngine" title="peri.opt.optimize.LMEngine"><code class="xref py py-class docutils literal"><span class="pre">peri.opt.optimize.LMEngine</span></code></a></dt>
<dd>The workhorse optimizer base class, called by
<a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMGlobals" title="peri.opt.optimize.LMGlobals"><code class="xref py py-class docutils literal"><span class="pre">LMGlobals</span></code></a> and <a class="reference internal" href="reference/opt.html#peri.opt.optimize.LMParticles" title="peri.opt.optimize.LMParticles"><code class="xref py py-class docutils literal"><span class="pre">LMParticles</span></code></a></dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="add-subtract">
<h2>Add-subtract<a class="headerlink" href="#add-subtract" title="Permalink to this headline">¶</a></h2>
<p>After the initial optimization we can add any missing particles and remove any
particles that shouldn&#8217;t be there. To do this, run:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">peri.opt.addsubtract</span> <span class="kn">as</span> <span class="nn">addsub</span>
<span class="n">num_changed</span><span class="p">,</span> <span class="n">removed_positions</span><span class="p">,</span> <span class="n">added_positions</span> <span class="o">=</span> <span class="n">addsub</span><span class="o">.</span><span class="n">add_subtract</span><span class="p">(</span><span class="n">st</span><span class="p">,</span>
        <span class="n">rad</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">,</span> <span class="n">min_rad</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">,</span> <span class="n">max_rad</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">max_npart</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>This function adds missing particles to the image by centroid-featuring the
residuals, with <code class="docutils literal"><span class="pre">invert</span></code> the same as for the initial centroid featuring &#8211;
set <code class="docutils literal"><span class="pre">invert=True</span></code> if the particles are dark on a bright background; <code class="docutils literal"><span class="pre">False</span></code>
otherwise. In the residuals image, missing particles stick out like sore thumbs
and are easy to find. The function adds a particle at this position with radius
<code class="docutils literal"><span class="pre">rad</span></code>; setting <code class="docutils literal"><span class="pre">rad='calc'</span></code> makes the function choose the radius internally
as the median radius of all the current particles.</p>
<p>More commonly however, two particles are initially featured as one. The initial
optimization will then split the difference by placing this one particle at a
position between the two particles and giving it a large radius. As a result,
the group of particles gets missed by the centroid featuring and particles are
not added. To combat this, the <code class="xref py py-func docutils literal"><span class="pre">add_subtract()</span></code> removes particles that
have a suspiciously large or small radii values, as determined by <code class="docutils literal"><span class="pre">min_rad</span></code>
and <code class="docutils literal"><span class="pre">max_rad</span></code>. (Setting these two to <code class="docutils literal"><span class="pre">'calc'</span></code> uses the cutoffs at the
median radius +/- 15 radii standard deviations.) With the incorrect large
particles removed, the missing particles can be featured. The function
repeatedly removes bad particles and adds missing particles until either no
change is made or it has iterated over the maximum number of loops.</p>
</div>
<div class="section" id="main-optimization">
<h2>Main Optimization<a class="headerlink" href="#main-optimization" title="Permalink to this headline">¶</a></h2>
<p>After adding all the particles, it&#8217;s time to completely optimize the state. In
my experience, sometimes adding particles causes the globals and the old
particle positions to no longer be correct. To deal with this, run something
like</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">opt</span><span class="o">.</span><span class="n">burn</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;burn&#39;</span><span class="p">,</span> <span class="n">n_loop</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">fractol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
</pre></div>
</div>
<p>This usually sets the illumination and particle positions to reasonable values.
At this point, it&#8217;s time to optimize all the state including the point-spread
function, which we have so far ignored. We can include this with rest of the
parameters with <a class="reference internal" href="reference/opt.html#peri.opt.optimize.burn" title="peri.opt.optimize.burn"><code class="xref py py-func docutils literal"><span class="pre">burn()</span></code></a> again:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">opt</span><span class="o">.</span><span class="n">burn</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;polish&#39;</span><span class="p">,</span> <span class="n">n_loop</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>What does this do? First, especially if the initial guess for the point-spread
function was correct, running another optimization with <code class="docutils literal"><span class="pre">mode='burn'</span></code> keeps
the point-spread function from drifting to a bad space because of its strong
coupling with the illumination field. Setting <code class="docutils literal"><span class="pre">mode='polish'</span></code> then causes
burn to optimize everything, alternating between an iteration of optimizing all
the global parameters (including the PSF) and an iteration of optimizing all
the particle positions. Similar to <code class="docutils literal"><span class="pre">mode='burn'</span></code>, setting <code class="docutils literal"><span class="pre">mode='polish'</span></code>
saves the state after each iteration by calling
<code class="docutils literal"><span class="pre">peri.states.save(st,</span> <span class="pre">desc='polishing')</span></code>; you can set <code class="docutils literal"><span class="pre">desc</span></code> to something
else if you&#8217;d like.</p>
</div>
<div class="section" id="achieving-the-best-possible-state">
<h2>Achieving the best-possible state<a class="headerlink" href="#achieving-the-best-possible-state" title="Permalink to this headline">¶</a></h2>
<p>Sometimes, after all this, particles are still missing or the fit is still not
perfect. There are still a few more tricks in the <code class="docutils literal"><span class="pre">peri</span></code> package to fix these
problems. These tricks are incorporated in the <a class="reference internal" href="reference/runner.html#peri.runner.finish_state" title="peri.runner.finish_state"><code class="xref py py-func docutils literal"><span class="pre">peri.runner.finish_state()</span></code></a>
for convenience. In case you find a better protocol for your images, here are
the tricks below.</p>
<div class="section" id="adding-tough-missing-particles">
<h3>Adding tough missing particles<a class="headerlink" href="#adding-tough-missing-particles" title="Permalink to this headline">¶</a></h3>
<p>Sometimes one pass of <a class="reference internal" href="reference/opt.html#peri.opt.addsubtract.add_subtract" title="peri.opt.addsubtract.add_subtract"><code class="xref py py-func docutils literal"><span class="pre">add_subtract()</span></code></a> is not enough
to find all the missing particles, or running the secondary optimizations
reveals that more particles are missing. In these cases, running another
<a class="reference internal" href="reference/opt.html#peri.opt.addsubtract.add_subtract" title="peri.opt.addsubtract.add_subtract"><code class="xref py py-func docutils literal"><span class="pre">add_subtract()</span></code></a> usually fixes the problem and gets
all the particles. However, sometimes there are particles that the normal
<a class="reference internal" href="reference/opt.html#peri.opt.addsubtract.add_subtract" title="peri.opt.addsubtract.add_subtract"><code class="xref py py-func docutils literal"><span class="pre">add_subtract()</span></code></a> just can&#8217;t seem to get right, such
as particles on the edge or tough clusters of particles. For these cases, there
is another function in the <code class="xref py py-mod docutils literal"><span class="pre">peri.opt.addsubtract</span></code> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">num_added</span><span class="p">,</span> <span class="n">added_positions</span> <span class="o">=</span> <span class="n">addsub</span><span class="o">.</span><span class="n">add_subtract_locally</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
</pre></div>
</div>
<p>Briefly, <a class="reference internal" href="reference/opt.html#peri.opt.addsubtract.add_subtract_locally" title="peri.opt.addsubtract.add_subtract_locally"><code class="xref py py-func docutils literal"><span class="pre">add_subtract_locally()</span></code></a> looks for poorly-
fit regions where the residuals deviate from white Gaussian noise, with the
size of the region roughly set by the optional parameter <code class="docutils literal"><span class="pre">filter_size</span></code>, and
the threshold for badness set by <code class="docutils literal"><span class="pre">sigma_cutoff</span></code>. The function then removes
<em>all</em> the particles in that region and re-adds them based on centroid featuring
again. Since <a class="reference internal" href="reference/opt.html#peri.opt.addsubtract.add_subtract_locally" title="peri.opt.addsubtract.add_subtract_locally"><code class="xref py py-func docutils literal"><span class="pre">add_subtract_locally()</span></code></a> removes all the
particles in the region, it&#8217;s best not to use it until the image is fairly well
fit. Otherwise, the function will attempt to remove nearly all the particles in
the image and re-add them, which takes a long time and will probably fail. That
being said, this function is excellent at fixing doubly-featured particle and
at identifying particles at the edge of or slightly outside of the image. You
can improve its chances of identifying particles at the very edge of the image
by passing a <code class="docutils literal"><span class="pre">minmass</span></code> parameter; I find that <code class="docutils literal"><span class="pre">minmass=0</span></code> frequently works
for particles at the edge of a well-fit state.</p>
</div>
<div class="section" id="additional-optimizations">
<h3>Additional Optimizations<a class="headerlink" href="#additional-optimizations" title="Permalink to this headline">¶</a></h3>
<p>Occasionally the number of optimization loops isn&#8217;t enough to completely
optimize a state. You can try to fix this by running a few more loops of
<a class="reference internal" href="reference/opt.html#peri.opt.optimize.burn" title="peri.opt.optimize.burn"><code class="xref py py-func docutils literal"><span class="pre">burn()</span></code></a> with <code class="docutils literal"><span class="pre">mode='burn'</span></code> or <code class="docutils literal"><span class="pre">mode='polish'</span></code>,
depending on whether the illumination is sufficiently far from the minimum as
to bias the PSF. But especially for large states, sometimes this is not enough.
In this case use</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">opt</span><span class="o">.</span><span class="n">finish</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="reference/opt.html#peri.opt.optimize.burn" title="peri.opt.optimize.burn"><code class="xref py py-func docutils literal"><span class="pre">burn()</span></code></a> makes some numerical approximations in the
least-squares fit to accelerate convegence. However, when the fit is near the
global minimum, sometimes <code class="docutils literal"><span class="pre">burn</span></code> can get stuck.
<a class="reference internal" href="reference/opt.html#peri.opt.optimize.finish" title="peri.opt.optimize.finish"><code class="xref py py-func docutils literal"><span class="pre">finish()</span></code></a> gets around this, taking a slightly slower
but surer descent to the minimum <a class="footnote-reference" href="#id6" id="id5">[3]</a>.</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>For the algorithm-savvy: A Levenberg-Marquardt algorithm works by
evaluating the derivative of the each residuals pixel with respect to
each parameter. A typical microscope image with <code class="docutils literal"><span class="pre">peri</span></code> has a few
million pixels and a few thousand parameters, making these derivatives
much too big to store in memory. <code class="docutils literal"><span class="pre">burn</span></code> gets around this by treating
the particles separately from the microscope parameters, and only
fitting the microscope parameters with a random subset of the image. But
taking this random subset causes <code class="docutils literal"><span class="pre">burn</span></code> to get slightly stuck with the
microscope parameters. <code class="docutils literal"><span class="pre">finish</span></code> gets around this by using the entire
image and alternating between fitting only a small subset of the
parameters at once. In addition, by default <code class="docutils literal"><span class="pre">finish</span></code> treats the PSF
separately, since it is more difficult to fit.</td></tr>
</tbody>
</table>
<p>Since I like to be sure that I&#8217;m at a global minimum, I always run a few extra
loops of <code class="docutils literal"><span class="pre">opt.burn</span></code> with <code class="docutils literal"><span class="pre">mode='polish'</span></code> or of <code class="docutils literal"><span class="pre">opt.finish</span></code> no matter
what.</p>
<p>What if the optimizer gets stuck? If the optimizer is stuck, and you know you
are not at the minimum, then you can individually optimize certain parameters.
For instance, if you know the PSF is not correct based on the way the residuals
looks, you can specifically optimize the PSF by doing this:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">opt</span><span class="o">.</span><span class="n">do_levmarq</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;psf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>or whatever global component you think is poorly optimized. If the error of the
state decreases significantly, then the state was not at the global minimum and
should be sent through another few loops of <code class="docutils literal"><span class="pre">opt.burn</span></code> or <code class="docutils literal"><span class="pre">opt.finish</span></code>.</p>
</div>
</div>
<div class="section" id="when-is-the-state-optimized">
<h2>When is the state optimized?<a class="headerlink" href="#when-is-the-state-optimized" title="Permalink to this headline">¶</a></h2>
<p>PERI relies on finding a global minimum of the fit. If the fit is not correct,
then obviously your extracted parameters such as positions and radii will not
be correct. How can you check if the state is optimized? Below are a few things
we check to see if a state is optimized. You can find many of these detailed in
the Supplemental Information for our paper.</p>
<div class="section" id="checking-optimization-with-the-orthomanipulator">
<h3>Checking optimization with the OrthoManipulator<a class="headerlink" href="#checking-optimization-with-the-orthomanipulator" title="Permalink to this headline">¶</a></h3>
<p>The best tool for checking optimization is the <a class="reference internal" href="reference/interaction.html#peri.viz.interaction.OrthoManipulator" title="peri.viz.interaction.OrthoManipulator"><code class="xref py py-class docutils literal"><span class="pre">peri.viz.interaction.OrthoManipulator</span></code></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">peri.viz.interaction</span> <span class="kn">import</span> <span class="n">OrthoManipulator</span>
<span class="n">OrthoManipulator</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>
</pre></div>
</div>
<p>This will pull up an interactive view of the state, with the data in one panel
and the state model in another. Pressing <code class="docutils literal"><span class="pre">Q</span></code> will cycle the view in the
second panel through the reconstructed model, the fit residuals, and individual
model components. To see if the fit is good, look at the fit residuals. Are
there missing particles, both in the middle of the frame and near the edges?
Can you see shadows of particles? If so, then the state is not optimized. In
contrast, if the residuals are nearly perfect white Gaussian noise, then you&#8217;re
done.</p>
<p>The <a class="reference internal" href="reference/interaction.html#peri.viz.interaction.OrthoManipulator" title="peri.viz.interaction.OrthoManipulator"><code class="xref py py-class docutils literal"><span class="pre">OrthoManipulator</span></code></a> has a lot of additional
functionality, including a view of the Fourier transform of the residuals and
the ability to add, remove, or optimize individual particles interactively. Try
it!</p>
</div>
<div class="section" id="checking-optimization-by-running-more-optimization">
<h3>Checking optimization by running more optimization<a class="headerlink" href="#checking-optimization-by-running-more-optimization" title="Permalink to this headline">¶</a></h3>
<p>Another way to check is simply to run more loops of <code class="docutils literal"><span class="pre">opt.burn</span></code> or
<code class="docutils literal"><span class="pre">opt.finish</span></code>. If the error or the parameters you care about change
significantly, then you probably needed to run more optimization loops. If not,
then you were near the minimum. While doing this for every image is probably
impractical, you can check a few images or a smaller section of an image to
see if your protocol is good.</p>
</div>
<div class="section" id="seeing-if-the-fitted-values-are-reasonable">
<h3>Seeing if the fitted values are reasonable<a class="headerlink" href="#seeing-if-the-fitted-values-are-reasonable" title="Permalink to this headline">¶</a></h3>
<p>Frequently it&#8217;s possible to tell if the fit is good simply by looking at the
parameters themselves. Do the particle radii vary systematically with <code class="docutils literal"><span class="pre">x</span></code>,
<code class="docutils literal"><span class="pre">y</span></code>, or <code class="docutils literal"><span class="pre">z</span></code>? If so, then the image is probbaly not at a good fit. We&#8217;ve
found that variations in <code class="docutils literal"><span class="pre">x</span></code> or <code class="docutils literal"><span class="pre">y</span></code> tend to be due to imperfections in the
ILM, which varies strongly in these directions for us, and variations in <code class="docutils literal"><span class="pre">z</span></code>
tend to be due to imperfections in the PSF, due to the increased aberration
with depth. Note that this might not just be a case of a poor fit &#8211; the
complexity of the model could be insufficient. You might need to use a more
realistic PSF or use a higher order for the ILM.</p>
<p>You can do similar checks by looking at either the fitted parameters of the PSF
and other components, or the actual fields themselves using the
<a class="reference internal" href="reference/interaction.html#peri.viz.interaction.OrthoManipulator" title="peri.viz.interaction.OrthoManipulator"><code class="xref py py-class docutils literal"><span class="pre">OrthoManipulator</span></code></a> or <a class="reference internal" href="reference/interaction.html#peri.viz.interaction.OrthoViewer" title="peri.viz.interaction.OrthoViewer"><code class="xref py py-class docutils literal"><span class="pre">OrthoViewer</span></code></a>.</p>
<p>As an aside, we don&#8217;t find it terribly useful to check if the residuals are at
the expected level of the noise. If you somehow knew exactly what the noise
level was, then you could check that <code class="docutils literal"><span class="pre">st.residuals.std()</span></code> is what it should
be. However, the difference between a good fit and a poor fit can be one-tenth
of a percent (i.e. 1e-3) of the residuals. It is highly unlikely that you know
the level of the noise to that precision &#8211; the noise level can vary by more
than that from frame-to-frame in a movie due to photobleaching or laser power
fluctuations.</p>
</div>
<div class="section" id="comparing-across-images">
<h3>Comparing across Images<a class="headerlink" href="#comparing-across-images" title="Permalink to this headline">¶</a></h3>
<p>Finally, you can compare parameters across images. If you featured multiple
images the same way, and the global parameters differ considerably (by
considerably more than the Cramer-Rao Bound), then the state is either not
fully optimized or the model is incomplete. The same applies if the particle
radii fluctuate considerably from frame-to-frame. You can check this easily
with <code class="xref py py-func docutils literal"><span class="pre">peri.test.track.calculate_state_radii_fluctuations()</span></code>.</p>
</div>
</div>
<div class="section" id="speeding-this-process-up">
<h2>Speeding this process up<a class="headerlink" href="#speeding-this-process-up" title="Permalink to this headline">¶</a></h2>
<p>Doing this process from start to finish can take a considerable amount of time.
In addition to the parallelization methods mentioned in <cite>Parallel&lt;/parallel&gt;</cite>,
here are a collection of several tricks to finding a good fit faster.</p>
<div class="section" id="using-a-good-initial-guess-the-runner-functions">
<h3>Using a Good Initial Guess; The Runner Functions<a class="headerlink" href="#using-a-good-initial-guess-the-runner-functions" title="Permalink to this headline">¶</a></h3>
<p>The best method for speeding up the featuring is to use a good initial guess.
If you know the ILM or the PSF accurately, then you can certainly save time by
avoiding the initial fits in <a class="reference internal" href="#initial-optimization">Initial Optimization</a>, and possibly even the
final fits in <a class="reference internal" href="#main-optimization">Main Optimization</a>.</p>
<p><code class="docutils literal"><span class="pre">peri</span></code> has convenience functions to use previously-optimized global paramters
in fitting an image. These (and others) are located in the <code class="docutils literal"><span class="pre">runner</span></code> module.
For instance, if you have a previously featured state saved as <code class="docutils literal"><span class="pre">state_name</span></code>,
this will feature a new image <code class="docutils literal"><span class="pre">'1.tif'</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">peri</span> <span class="kn">import</span> <span class="n">runner</span>
<span class="n">feature_diam</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1">#or whatever feature_diam is best for centroid methods</span>
<span class="n">actual_rad</span> <span class="o">=</span> <span class="mf">5.38</span>  <span class="c1">#the actual radius in pixels of the particles</span>

<span class="n">st</span> <span class="o">=</span> <span class="n">runner</span><span class="o">.</span><span class="n">get_particles_featuring</span><span class="p">(</span><span class="n">feature_diam</span><span class="p">,</span> <span class="n">state_name</span><span class="o">=</span><span class="n">state_name</span><span class="p">,</span>
        <span class="n">im_name</span><span class="o">=</span><span class="s1">&#39;1.tif&#39;</span><span class="p">,</span> <span class="n">actual_rad</span><span class="o">=</span><span class="n">actual_rad</span><span class="p">,</span> <span class="n">do_polish</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">runner.get_particles_featuring</span></code> takes all of the global parameters from the
state <code class="docutils literal"><span class="pre">state_name</span></code>, switches the image, and re-features an initial guess with
centroid methods. It then optimizes the particle positions and radii before
returning. Setting <code class="docutils literal"><span class="pre">do_polish</span></code> to True will automatically run an
<code class="docutils literal"><span class="pre">opt.burn(st,</span> <span class="pre">mode='polish')</span></code> on both the globals and particles before
returning the state (takes more time), but this can be omitted for speed. The
state is automatically saved at several points. Similar functionality is
provided by some other of the <code class="docutils literal"><span class="pre">runner</span></code> functions &#8211; for instance,
<code class="docutils literal"><span class="pre">runner.translate_featuring</span></code> if the particle positions haven&#8217;t moved much
between the loaded state and the new image.</p>
</div>
<div class="section" id="fitting-a-small-image">
<h3>Fitting a small image<a class="headerlink" href="#fitting-a-small-image" title="Permalink to this headline">¶</a></h3>
<p>The larger the image is, the longer it takes to fit. Fitting a small image
considerably speeds up the fit. You can change the region of the fit by setting
the <a class="reference internal" href="reference/util.html#peri.util.Tile" title="peri.util.Tile"><code class="xref py py-class docutils literal"><span class="pre">peri.util.Tile</span></code></a> of the image, as described in section BLAH.</p>
<p>Fitting a small image is useful to get a good estimate of global parameters,
especially the point-spread function. Since the exact point-spread functions
included in peri change only with <code class="docutils literal"><span class="pre">z</span></code>, fitting a small portion of the image
in <code class="docutils literal"><span class="pre">x</span></code> and <code class="docutils literal"><span class="pre">y</span></code> but over the full <code class="docutils literal"><span class="pre">z</span></code> extent will still give an accurate
PSF.</p>
<p>We highly encourage you do fit a small image very well to find a good PSF. The
PSF is difficult to optimize (its optimization space is far from a simple
quadratic, and there are slow directions in the fit). Highly-optimizing a small
state to get an accurate PSF will do more than save a <em>lot</em> of time later. For
larger states the optimizer can even get stuck and terminate, thinking it is at
a good fit when it reality the PSF is far from the minimum, which can severely
bias your fits. Make a small image and optimize it overnight &#8211; say, 50-100
loops of <code class="docutils literal"><span class="pre">opt.burn</span></code> with <code class="docutils literal"><span class="pre">mode='polish'</span></code> to ensure that you&#8217;ve found the
global minimum. You might even want to alternate a loop of burn with a direct
minimization of the PSF, like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">state_vals</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1">#storing to check at the end</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">50</span><span class="p">):</span>  <span class="c1">#or another big number</span>
    <span class="n">opt</span><span class="o">.</span><span class="n">burn</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;polish&#39;</span><span class="p">,</span> <span class="n">n_loop</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">opt</span><span class="o">.</span><span class="n">do_levmarq</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">st</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;psf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="n">state_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">state</span><span class="p">[</span><span class="n">st</span><span class="o">.</span><span class="n">params</span><span class="p">]))</span>
</pre></div>
</div>
<p>When it finishes, check that the parameters have stopped changing by plotting
them. For instance, to check the parameter <code class="docutils literal"><span class="pre">psf-alpha</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;psf-alpha&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">state_vals</span><span class="p">[:,</span><span class="n">index</span><span class="p">])</span>
</pre></div>
</div>
<p>You should see it smoothly approach a constant value. If it doesn&#8217;t look
converged, then keep optimizing. If you change your imaging conditions &#8211; the
index of refraction of the solvent or the microscope and lens &#8211; then you will
need to do this again.</p>
</div>
<div class="section" id="sacrificing-precision-for-speed">
<h3>Sacrificing Precision for Speed<a class="headerlink" href="#sacrificing-precision-for-speed" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">peri</span></code> is designed to extract information at the maximum possible accuracy.
It does this by finding the best fit of an accurate model to the data. If you
don&#8217;t need the maximal possible accuracy, then running <code class="docutils literal"><span class="pre">peri</span></code> to completion
is overkill. For instance, if you just want to distinguish which size a
particle is in a bidisperse suspension, finding the particle radii accurately
to 1 nm is not necessary.</p>
<p>If this is the case, you can save some time by running less optimization loops
or not worrying about finding every last particle. You might also be able to
save time by using a less accurate model &#8211; for instance, you could use an ILM
of lower order to create less parameters to fit, or a less accurate PSF to
decrease the execution time for one model generation. You can find some of
these inexact PSFs in <code class="xref py py-mod docutils literal"><span class="pre">peri.comp.psfs</span></code>, along with a description of how well
they work in the paper&#8217;s Supplemental Information.</p>
</div>
<div class="section" id="inventing-a-new-algorithm-for-fitting-in-high-dimensional-spaces">
<h3>Inventing a new algorithm for fitting in high-dimensional spaces<a class="headerlink" href="#inventing-a-new-algorithm-for-fitting-in-high-dimensional-spaces" title="Permalink to this headline">¶</a></h3>
<p>Please do this.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Optimization and sampling</a><ul>
<li><a class="reference internal" href="#initial-optimization">Initial Optimization</a></li>
<li><a class="reference internal" href="#add-subtract">Add-subtract</a></li>
<li><a class="reference internal" href="#main-optimization">Main Optimization</a></li>
<li><a class="reference internal" href="#achieving-the-best-possible-state">Achieving the best-possible state</a><ul>
<li><a class="reference internal" href="#adding-tough-missing-particles">Adding tough missing particles</a></li>
<li><a class="reference internal" href="#additional-optimizations">Additional Optimizations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#when-is-the-state-optimized">When is the state optimized?</a><ul>
<li><a class="reference internal" href="#checking-optimization-with-the-orthomanipulator">Checking optimization with the OrthoManipulator</a></li>
<li><a class="reference internal" href="#checking-optimization-by-running-more-optimization">Checking optimization by running more optimization</a></li>
<li><a class="reference internal" href="#seeing-if-the-fitted-values-are-reasonable">Seeing if the fitted values are reasonable</a></li>
<li><a class="reference internal" href="#comparing-across-images">Comparing across Images</a></li>
</ul>
</li>
<li><a class="reference internal" href="#speeding-this-process-up">Speeding this process up</a><ul>
<li><a class="reference internal" href="#using-a-good-initial-guess-the-runner-functions">Using a Good Initial Guess; The Runner Functions</a></li>
<li><a class="reference internal" href="#fitting-a-small-image">Fitting a small image</a></li>
<li><a class="reference internal" href="#sacrificing-precision-for-speed">Sacrificing Precision for Speed</a></li>
<li><a class="reference internal" href="#inventing-a-new-algorithm-for-fitting-in-high-dimensional-spaces">Inventing a new algorithm for fitting in high-dimensional spaces</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="architecture.html"
                        title="previous chapter">Package architecture</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="reference/comp.html"
                        title="next chapter">peri.comp</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/optimization.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="reference/comp.html" title="peri.comp"
             >next</a> |</li>
        <li class="right" >
          <a href="architecture.html" title="Package architecture"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">PERI 0.1.1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, Matt Bierbaum, Brian Leahy.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>